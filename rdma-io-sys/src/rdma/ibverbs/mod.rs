// Bindings generated by `windows-bindgen` 0.66.0

#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    dead_code,
    clippy::all
)]

windows_link::link!("ibverbs" "C" fn ___ibv_query_port(context : *mut ibv_context, port_num : u8, port_attr : *mut ibv_port_attr) -> i32);
windows_link::link!("ibverbs" "C" fn __ibv_reg_mr(pd : *mut ibv_pd, addr : *mut core::ffi::c_void, length : u64, access : u32, is_access_const : i32) -> *mut ibv_mr);
windows_link::link!("ibverbs" "C" fn __ibv_reg_mr_iova(pd : *mut ibv_pd, addr : *mut core::ffi::c_void, length : u64, iova : u64, access : u32, is_access_const : i32) -> *mut ibv_mr);
windows_link::link!("ibverbs" "C" fn _ibv_query_gid_ex(context : *mut ibv_context, port_num : u32, gid_index : u32, entry : *mut ibv_gid_entry, flags : u32, entry_size : u64) -> i32);
windows_link::link!("ibverbs" "C" fn _ibv_query_gid_table(context : *mut ibv_context, entries : *mut ibv_gid_entry, max_entries : u64, flags : u32, entry_size : u64) -> bnd_posix::posix::types:: ssize_t);
windows_link::link!("ibverbs" "C" fn ibv_ack_async_event(event : *mut ibv_async_event));
windows_link::link!("ibverbs" "C" fn ibv_ack_cq_events(cq : *mut ibv_cq, nevents : u32));
windows_link::link!("ibverbs" "C" fn ibv_advise_mr(pd : *mut ibv_pd, advice : ib_uverbs_advise_mr_advice, flags : u32, sg_list : *mut ibv_sge, num_sge : u32) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_alloc_dm(context : *mut ibv_context, attr : *mut ibv_alloc_dm_attr) -> *mut ibv_dm);
windows_link::link!("ibverbs" "C" fn ibv_alloc_mw(pd : *mut ibv_pd, r#type : ibv_mw_type) -> *mut ibv_mw);
windows_link::link!("ibverbs" "C" fn ibv_alloc_null_mr(pd : *mut ibv_pd) -> *mut ibv_mr);
windows_link::link!("ibverbs" "C" fn ibv_alloc_parent_domain(context : *mut ibv_context, attr : *mut ibv_parent_domain_init_attr) -> *mut ibv_pd);
windows_link::link!("ibverbs" "C" fn ibv_alloc_pd(context : *mut ibv_context) -> *mut ibv_pd);
windows_link::link!("ibverbs" "C" fn ibv_alloc_td(context : *mut ibv_context, init_attr : *mut ibv_td_init_attr) -> *mut ibv_td);
windows_link::link!("ibverbs" "C" fn ibv_attach_counters_point_flow(counters : *mut ibv_counters, attr : *mut ibv_counter_attach_attr, flow : *mut ibv_flow) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_attach_mcast(qp : *mut ibv_qp, gid : *const ibv_gid, lid : u16) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_bind_mw(qp : *mut ibv_qp, mw : *mut ibv_mw, mw_bind : *mut ibv_mw_bind) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_close_device(context : *mut ibv_context) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_close_xrcd(xrcd : *mut ibv_xrcd) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_cq_ex_to_cq(cq : *mut ibv_cq_ex) -> *mut ibv_cq);
windows_link::link!("ibverbs" "C" fn ibv_create_ah(pd : *mut ibv_pd, attr : *mut ibv_ah_attr) -> *mut ibv_ah);
windows_link::link!("ibverbs" "C" fn ibv_create_ah_from_wc(pd : *mut ibv_pd, wc : *mut ibv_wc, grh : *mut ibv_grh, port_num : u8) -> *mut ibv_ah);
windows_link::link!("ibverbs" "C" fn ibv_create_comp_channel(context : *mut ibv_context) -> *mut ibv_comp_channel);
windows_link::link!("ibverbs" "C" fn ibv_create_counters(context : *mut ibv_context, init_attr : *mut ibv_counters_init_attr) -> *mut ibv_counters);
windows_link::link!("ibverbs" "C" fn ibv_create_cq(context : *mut ibv_context, cqe : i32, cq_context : *mut core::ffi::c_void, channel : *mut ibv_comp_channel, comp_vector : i32) -> *mut ibv_cq);
windows_link::link!("ibverbs" "C" fn ibv_create_cq_ex(context : *mut ibv_context, cq_attr : *mut ibv_cq_init_attr_ex) -> *mut ibv_cq_ex);
windows_link::link!("ibverbs" "C" fn ibv_create_flow(qp : *mut ibv_qp, flow : *mut ibv_flow_attr) -> *mut ibv_flow);
windows_link::link!("ibverbs" "C" fn ibv_create_flow_action_esp(ctx : *mut ibv_context, esp : *mut ibv_flow_action_esp_attr) -> *mut ibv_flow_action);
windows_link::link!("ibverbs" "C" fn ibv_create_qp(pd : *mut ibv_pd, qp_init_attr : *mut ibv_qp_init_attr) -> *mut ibv_qp);
windows_link::link!("ibverbs" "C" fn ibv_create_qp_ex(context : *mut ibv_context, qp_init_attr_ex : *mut ibv_qp_init_attr_ex) -> *mut ibv_qp);
windows_link::link!("ibverbs" "C" fn ibv_create_rwq_ind_table(context : *mut ibv_context, init_attr : *mut ibv_rwq_ind_table_init_attr) -> *mut ibv_rwq_ind_table);
windows_link::link!("ibverbs" "C" fn ibv_create_srq(pd : *mut ibv_pd, srq_init_attr : *mut ibv_srq_init_attr) -> *mut ibv_srq);
windows_link::link!("ibverbs" "C" fn ibv_create_srq_ex(context : *mut ibv_context, srq_init_attr_ex : *mut ibv_srq_init_attr_ex) -> *mut ibv_srq);
windows_link::link!("ibverbs" "C" fn ibv_create_wq(context : *mut ibv_context, wq_init_attr : *mut ibv_wq_init_attr) -> *mut ibv_wq);
windows_link::link!("ibverbs" "C" fn ibv_dealloc_mw(mw : *mut ibv_mw) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_dealloc_pd(pd : *mut ibv_pd) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_dealloc_td(td : *mut ibv_td) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_dereg_mr(mr : *mut ibv_mr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_destroy_ah(ah : *mut ibv_ah) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_destroy_comp_channel(channel : *mut ibv_comp_channel) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_destroy_counters(counters : *mut ibv_counters) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_destroy_cq(cq : *mut ibv_cq) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_destroy_flow(flow_id : *mut ibv_flow) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_destroy_flow_action(action : *mut ibv_flow_action) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_destroy_qp(qp : *mut ibv_qp) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_destroy_rwq_ind_table(rwq_ind_table : *mut ibv_rwq_ind_table) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_destroy_srq(srq : *mut ibv_srq) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_destroy_wq(wq : *mut ibv_wq) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_detach_mcast(qp : *mut ibv_qp, gid : *const ibv_gid, lid : u16) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_end_poll(cq : *mut ibv_cq_ex));
windows_link::link!("ibverbs" "C" fn ibv_event_type_str(event : ibv_event_type) -> *mut i8);
windows_link::link!("ibverbs" "C" fn ibv_flow_label_to_udp_sport(fl : u32) -> u16);
windows_link::link!("ibverbs" "C" fn ibv_fork_init() -> i32);
windows_link::link!("ibverbs" "C" fn ibv_free_device_list(list : *mut *mut ibv_device));
windows_link::link!("ibverbs" "C" fn ibv_free_dm(dm : *mut ibv_dm) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_get_async_event(context : *mut ibv_context, event : *mut ibv_async_event) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_get_cq_event(channel : *mut ibv_comp_channel, cq : *mut *mut ibv_cq, cq_context : *mut *mut core::ffi::c_void) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_get_device_guid(device : *mut ibv_device) -> bnd_linux::linux::types:: __be64);
windows_link::link!("ibverbs" "C" fn ibv_get_device_index(device : *mut ibv_device) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_get_device_list(num_devices : *mut i32) -> *mut *mut ibv_device);
windows_link::link!("ibverbs" "C" fn ibv_get_device_name(device : *mut ibv_device) -> *mut i8);
windows_link::link!("ibverbs" "C" fn ibv_get_pkey_index(context : *mut ibv_context, port_num : u8, pkey : bnd_linux::linux::types:: __be16) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_get_srq_num(srq : *mut ibv_srq, srq_num : *mut u32) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_import_device(cmd_fd : i32) -> *mut ibv_context);
windows_link::link!("ibverbs" "C" fn ibv_import_dm(context : *mut ibv_context, dm_handle : u32) -> *mut ibv_dm);
windows_link::link!("ibverbs" "C" fn ibv_import_mr(pd : *mut ibv_pd, mr_handle : u32) -> *mut ibv_mr);
windows_link::link!("ibverbs" "C" fn ibv_import_pd(context : *mut ibv_context, pd_handle : u32) -> *mut ibv_pd);
windows_link::link!("ibverbs" "C" fn ibv_inc_rkey(rkey : u32) -> u32);
windows_link::link!("ibverbs" "C" fn ibv_init_ah_from_wc(context : *mut ibv_context, port_num : u8, wc : *mut ibv_wc, grh : *mut ibv_grh, ah_attr : *mut ibv_ah_attr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_is_fork_initialized() -> ibv_fork_status);
windows_link::link!("ibverbs" "C" fn ibv_is_qpt_supported(caps : u32, qpt : ibv_qp_type) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_memcpy_from_dm(host_addr : *mut core::ffi::c_void, dm : *mut ibv_dm, dm_offset : u64, length : u64) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_memcpy_to_dm(dm : *mut ibv_dm, dm_offset : u64, host_addr : *const core::ffi::c_void, length : u64) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_modify_cq(cq : *mut ibv_cq, attr : *mut ibv_modify_cq_attr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_modify_flow_action_esp(action : *mut ibv_flow_action, esp : *mut ibv_flow_action_esp_attr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_modify_qp(qp : *mut ibv_qp, attr : *mut ibv_qp_attr, attr_mask : i32) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_modify_qp_rate_limit(qp : *mut ibv_qp, attr : *mut ibv_qp_rate_limit_attr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_modify_srq(srq : *mut ibv_srq, srq_attr : *mut ibv_srq_attr, srq_attr_mask : i32) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_modify_wq(wq : *mut ibv_wq, wq_attr : *mut ibv_wq_attr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_next_poll(cq : *mut ibv_cq_ex) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_node_type_str(node_type : ibv_node_type) -> *mut i8);
windows_link::link!("ibverbs" "C" fn ibv_open_device(device : *mut ibv_device) -> *mut ibv_context);
windows_link::link!("ibverbs" "C" fn ibv_open_qp(context : *mut ibv_context, qp_open_attr : *mut ibv_qp_open_attr) -> *mut ibv_qp);
windows_link::link!("ibverbs" "C" fn ibv_open_xrcd(context : *mut ibv_context, xrcd_init_attr : *mut ibv_xrcd_init_attr) -> *mut ibv_xrcd);
windows_link::link!("ibverbs" "C" fn ibv_poll_cq(cq : *mut ibv_cq, num_entries : i32, wc : *mut ibv_wc) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_port_state_str(port_state : ibv_port_state) -> *mut i8);
windows_link::link!("ibverbs" "C" fn ibv_post_recv(qp : *mut ibv_qp, wr : *mut ibv_recv_wr, bad_wr : *mut *mut ibv_recv_wr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_post_send(qp : *mut ibv_qp, wr : *mut ibv_send_wr, bad_wr : *mut *mut ibv_send_wr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_post_srq_ops(srq : *mut ibv_srq, op : *mut ibv_ops_wr, bad_op : *mut *mut ibv_ops_wr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_post_srq_recv(srq : *mut ibv_srq, recv_wr : *mut ibv_recv_wr, bad_recv_wr : *mut *mut ibv_recv_wr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_post_wq_recv(wq : *mut ibv_wq, recv_wr : *mut ibv_recv_wr, bad_recv_wr : *mut *mut ibv_recv_wr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_qp_to_qp_ex(qp : *mut ibv_qp) -> *mut ibv_qp_ex);
windows_link::link!("ibverbs" "C" fn ibv_query_device(context : *mut ibv_context, device_attr : *mut ibv_device_attr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_query_device_ex(context : *mut ibv_context, input : *const ibv_query_device_ex_input, attr : *mut ibv_device_attr_ex) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_query_ece(qp : *mut ibv_qp, ece : *mut ibv_ece) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_query_gid(context : *mut ibv_context, port_num : u8, index : i32, gid : *mut ibv_gid) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_query_gid_ex(context : *mut ibv_context, port_num : u32, gid_index : u32, entry : *mut ibv_gid_entry, flags : u32) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_query_gid_table(context : *mut ibv_context, entries : *mut ibv_gid_entry, max_entries : u64, flags : u32) -> bnd_posix::posix::types:: ssize_t);
windows_link::link!("ibverbs" "C" fn ibv_query_pkey(context : *mut ibv_context, port_num : u8, index : i32, pkey : *mut bnd_linux::linux::types:: __be16) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_query_port(context : *mut ibv_context, port_num : u8, port_attr : *mut core::ffi::c_void) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_query_qp(qp : *mut ibv_qp, attr : *mut ibv_qp_attr, attr_mask : i32, init_attr : *mut ibv_qp_init_attr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_query_qp_data_in_order(qp : *mut ibv_qp, op : ibv_wr_opcode, flags : u32) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_query_rt_values_ex(context : *mut ibv_context, values : *mut ibv_values_ex) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_query_srq(srq : *mut ibv_srq, srq_attr : *mut ibv_srq_attr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_rate_to_mbps(rate : ibv_rate) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_rate_to_mult(rate : ibv_rate) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_read_counters(counters : *mut ibv_counters, counters_value : *mut u64, ncounters : u32, flags : u32) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_reg_dm_mr(pd : *mut ibv_pd, dm : *mut ibv_dm, dm_offset : u64, length : u64, access : u32) -> *mut ibv_mr);
windows_link::link!("ibverbs" "C" fn ibv_reg_dmabuf_mr(pd : *mut ibv_pd, offset : u64, length : u64, iova : u64, fd : i32, access : i32) -> *mut ibv_mr);
windows_link::link!("ibverbs" "C" fn ibv_reg_mr(pd : *mut ibv_pd, addr : *mut core::ffi::c_void, length : u64, access : i32) -> *mut ibv_mr);
windows_link::link!("ibverbs" "C" fn ibv_reg_mr_iova(pd : *mut ibv_pd, addr : *mut core::ffi::c_void, length : u64, iova : u64, access : i32) -> *mut ibv_mr);
windows_link::link!("ibverbs" "C" fn ibv_reg_mr_iova2(pd : *mut ibv_pd, addr : *mut core::ffi::c_void, length : u64, iova : u64, access : u32) -> *mut ibv_mr);
windows_link::link!("ibverbs" "C" fn ibv_req_notify_cq(cq : *mut ibv_cq, solicited_only : i32) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_rereg_mr(mr : *mut ibv_mr, flags : i32, pd : *mut ibv_pd, addr : *mut core::ffi::c_void, length : u64, access : i32) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_resize_cq(cq : *mut ibv_cq, cqe : i32) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_resolve_eth_l2_from_gid(context : *mut ibv_context, attr : *mut ibv_ah_attr, eth_mac : *mut u8, vid : *mut u16) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_set_ece(qp : *mut ibv_qp, ece : *mut ibv_ece) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_start_poll(cq : *mut ibv_cq_ex, attr : *mut ibv_poll_cq_attr) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_unimport_dm(dm : *mut ibv_dm));
windows_link::link!("ibverbs" "C" fn ibv_unimport_mr(mr : *mut ibv_mr));
windows_link::link!("ibverbs" "C" fn ibv_unimport_pd(pd : *mut ibv_pd));
windows_link::link!("ibverbs" "C" fn ibv_wc_read_byte_len(cq : *mut ibv_cq_ex) -> u32);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_completion_ts(cq : *mut ibv_cq_ex) -> u64);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_completion_wallclock_ns(cq : *mut ibv_cq_ex) -> u64);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_cvlan(cq : *mut ibv_cq_ex) -> u16);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_dlid_path_bits(cq : *mut ibv_cq_ex) -> u8);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_flow_tag(cq : *mut ibv_cq_ex) -> u32);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_imm_data(cq : *mut ibv_cq_ex) -> bnd_linux::linux::types:: __be32);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_invalidated_rkey(cq : *mut ibv_cq_ex) -> u32);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_opcode(cq : *mut ibv_cq_ex) -> ibv_wc_opcode);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_qp_num(cq : *mut ibv_cq_ex) -> u32);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_sl(cq : *mut ibv_cq_ex) -> u8);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_slid(cq : *mut ibv_cq_ex) -> u32);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_src_qp(cq : *mut ibv_cq_ex) -> u32);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_tm_info(cq : *mut ibv_cq_ex, tm_info : *mut ibv_wc_tm_info));
windows_link::link!("ibverbs" "C" fn ibv_wc_read_vendor_err(cq : *mut ibv_cq_ex) -> u32);
windows_link::link!("ibverbs" "C" fn ibv_wc_read_wc_flags(cq : *mut ibv_cq_ex) -> u32);
windows_link::link!("ibverbs" "C" fn ibv_wc_status_str(status : ibv_wc_status) -> *mut i8);
windows_link::link!("ibverbs" "C" fn ibv_wr_abort(qp : *mut ibv_qp_ex));
windows_link::link!("ibverbs" "C" fn ibv_wr_atomic_cmp_swp(qp : *mut ibv_qp_ex, rkey : u32, remote_addr : u64, compare : u64, swap : u64));
windows_link::link!("ibverbs" "C" fn ibv_wr_atomic_fetch_add(qp : *mut ibv_qp_ex, rkey : u32, remote_addr : u64, add : u64));
windows_link::link!("ibverbs" "C" fn ibv_wr_atomic_write(qp : *mut ibv_qp_ex, rkey : u32, remote_addr : u64, atomic_wr : *const core::ffi::c_void));
windows_link::link!("ibverbs" "C" fn ibv_wr_bind_mw(qp : *mut ibv_qp_ex, mw : *mut ibv_mw, rkey : u32, bind_info : *const ibv_mw_bind_info));
windows_link::link!("ibverbs" "C" fn ibv_wr_complete(qp : *mut ibv_qp_ex) -> i32);
windows_link::link!("ibverbs" "C" fn ibv_wr_flush(qp : *mut ibv_qp_ex, rkey : u32, remote_addr : u64, len : u64, r#type : u8, level : u8));
windows_link::link!("ibverbs" "C" fn ibv_wr_local_inv(qp : *mut ibv_qp_ex, invalidate_rkey : u32));
windows_link::link!("ibverbs" "C" fn ibv_wr_opcode_str(opcode : ibv_wr_opcode) -> *mut i8);
windows_link::link!("ibverbs" "C" fn ibv_wr_rdma_read(qp : *mut ibv_qp_ex, rkey : u32, remote_addr : u64));
windows_link::link!("ibverbs" "C" fn ibv_wr_rdma_write(qp : *mut ibv_qp_ex, rkey : u32, remote_addr : u64));
windows_link::link!("ibverbs" "C" fn ibv_wr_rdma_write_imm(qp : *mut ibv_qp_ex, rkey : u32, remote_addr : u64, imm_data : bnd_linux::linux::types:: __be32));
windows_link::link!("ibverbs" "C" fn ibv_wr_send(qp : *mut ibv_qp_ex));
windows_link::link!("ibverbs" "C" fn ibv_wr_send_imm(qp : *mut ibv_qp_ex, imm_data : bnd_linux::linux::types:: __be32));
windows_link::link!("ibverbs" "C" fn ibv_wr_send_inv(qp : *mut ibv_qp_ex, invalidate_rkey : u32));
windows_link::link!("ibverbs" "C" fn ibv_wr_send_tso(qp : *mut ibv_qp_ex, hdr : *mut core::ffi::c_void, hdr_sz : u16, mss : u16));
windows_link::link!("ibverbs" "C" fn ibv_wr_set_inline_data(qp : *mut ibv_qp_ex, addr : *mut core::ffi::c_void, length : u64));
windows_link::link!("ibverbs" "C" fn ibv_wr_set_inline_data_list(qp : *mut ibv_qp_ex, num_buf : u64, buf_list : *const ibv_data_buf));
windows_link::link!("ibverbs" "C" fn ibv_wr_set_sge(qp : *mut ibv_qp_ex, lkey : u32, addr : u64, length : u32));
windows_link::link!("ibverbs" "C" fn ibv_wr_set_sge_list(qp : *mut ibv_qp_ex, num_sge : u64, sg_list : *const ibv_sge));
windows_link::link!("ibverbs" "C" fn ibv_wr_set_ud_addr(qp : *mut ibv_qp_ex, ah : *mut ibv_ah, remote_qpn : u32, remote_qkey : u32));
windows_link::link!("ibverbs" "C" fn ibv_wr_set_xrc_srqn(qp : *mut ibv_qp_ex, remote_srqn : u32));
windows_link::link!("ibverbs" "C" fn ibv_wr_start(qp : *mut ibv_qp_ex));
windows_link::link!("ibverbs" "C" fn mbps_to_ibv_rate(mbps : i32) -> ibv_rate);
windows_link::link!("ibverbs" "C" fn mult_to_ibv_rate(mult : i32) -> ibv_rate);
windows_link::link!("ibverbs" "C" fn verbs_get_ctx(ctx : *mut ibv_context) -> *mut verbs_context);
pub const ETHERNET_LL_SIZE: i32 = 6i32;
pub const IBV_ACCESS_FLUSH_GLOBAL: u32 = 256u32;
pub const IBV_ACCESS_FLUSH_PERSISTENT: u32 = 512u32;
pub const IBV_ACCESS_HUGETLB: u32 = 128u32;
pub const IBV_ACCESS_LOCAL_WRITE: u32 = 1u32;
pub const IBV_ACCESS_MW_BIND: u32 = 16u32;
pub const IBV_ACCESS_ON_DEMAND: u32 = 64u32;
pub const IBV_ACCESS_RELAXED_ORDERING: u32 = 1048576u32;
pub const IBV_ACCESS_REMOTE_ATOMIC: u32 = 8u32;
pub const IBV_ACCESS_REMOTE_READ: u32 = 4u32;
pub const IBV_ACCESS_REMOTE_WRITE: u32 = 2u32;
pub const IBV_ACCESS_ZERO_BASED: u32 = 32u32;
pub const IBV_ATOMIC_GLOB: u32 = 2u32;
pub const IBV_ATOMIC_HCA: u32 = 1u32;
pub const IBV_ATOMIC_NONE: u32 = 0u32;
pub const IBV_COUNTER_BYTES: u32 = 1u32;
pub const IBV_COUNTER_PACKETS: u32 = 0u32;
pub const IBV_CQ_ATTR_MODERATE: u32 = 1u32;
pub const IBV_CQ_ATTR_RESERVED: u32 = 2u32;
pub const IBV_CQ_INIT_ATTR_MASK_FLAGS: u32 = 1u32;
pub const IBV_CQ_INIT_ATTR_MASK_PD: u32 = 2u32;
pub const IBV_CREATE_CQ_ATTR_IGNORE_OVERRUN: u32 = 2u32;
pub const IBV_CREATE_CQ_ATTR_SINGLE_THREADED: u32 = 1u32;
pub const IBV_CREATE_CQ_SUP_WC_FLAGS: u32 = 4095u32;
pub const IBV_CREATE_IND_TABLE_RESERVED: u32 = 1u32;
pub const IBV_DEVICE_AUTO_PATH_MIG: u32 = 16u32;
pub const IBV_DEVICE_BAD_PKEY_CNTR: u32 = 2u32;
pub const IBV_DEVICE_BAD_QKEY_CNTR: u32 = 4u32;
pub const IBV_DEVICE_CHANGE_PHY_PORT: u32 = 32u32;
pub const IBV_DEVICE_CURR_QP_STATE_MOD: u32 = 128u32;
pub const IBV_DEVICE_INIT_TYPE: u32 = 512u32;
pub const IBV_DEVICE_MANAGED_FLOW_STEERING: u32 = 536870912u32;
pub const IBV_DEVICE_MEM_MGT_EXTENSIONS: u32 = 2097152u32;
pub const IBV_DEVICE_MEM_WINDOW: u32 = 131072u32;
pub const IBV_DEVICE_MEM_WINDOW_TYPE_2A: u32 = 8388608u32;
pub const IBV_DEVICE_MEM_WINDOW_TYPE_2B: u32 = 16777216u32;
pub const IBV_DEVICE_N_NOTIFY_CQ: u32 = 16384u32;
pub const IBV_DEVICE_PORT_ACTIVE_EVENT: u32 = 1024u32;
pub const IBV_DEVICE_RAW_IP_CSUM: u32 = 67108864u32;
pub const IBV_DEVICE_RAW_MULTI: u32 = 8u32;
pub const IBV_DEVICE_RC_IP_CSUM: u32 = 33554432u32;
pub const IBV_DEVICE_RC_RNR_NAK_GEN: u32 = 4096u32;
pub const IBV_DEVICE_RESIZE_MAX_WR: u32 = 1u32;
pub const IBV_DEVICE_SHUTDOWN_PORT: u32 = 256u32;
pub const IBV_DEVICE_SRQ_RESIZE: u32 = 8192u32;
pub const IBV_DEVICE_SYS_IMAGE_GUID: u32 = 2048u32;
pub const IBV_DEVICE_UD_AV_PORT_ENFORCE: u32 = 64u32;
pub const IBV_DEVICE_UD_IP_CSUM: u32 = 262144u32;
pub const IBV_DEVICE_XRC: u32 = 1048576u32;
pub const IBV_DM_MASK_HANDLE: u32 = 1u32;
pub const IBV_EVENT_CLIENT_REREGISTER: u32 = 17u32;
pub const IBV_EVENT_COMM_EST: u32 = 4u32;
pub const IBV_EVENT_CQ_ERR: u32 = 0u32;
pub const IBV_EVENT_DEVICE_FATAL: u32 = 8u32;
pub const IBV_EVENT_GID_CHANGE: u32 = 18u32;
pub const IBV_EVENT_LID_CHANGE: u32 = 11u32;
pub const IBV_EVENT_PATH_MIG: u32 = 6u32;
pub const IBV_EVENT_PATH_MIG_ERR: u32 = 7u32;
pub const IBV_EVENT_PKEY_CHANGE: u32 = 12u32;
pub const IBV_EVENT_PORT_ACTIVE: u32 = 9u32;
pub const IBV_EVENT_PORT_ERR: u32 = 10u32;
pub const IBV_EVENT_QP_ACCESS_ERR: u32 = 3u32;
pub const IBV_EVENT_QP_FATAL: u32 = 1u32;
pub const IBV_EVENT_QP_LAST_WQE_REACHED: u32 = 16u32;
pub const IBV_EVENT_QP_REQ_ERR: u32 = 2u32;
pub const IBV_EVENT_SM_CHANGE: u32 = 13u32;
pub const IBV_EVENT_SQ_DRAINED: u32 = 5u32;
pub const IBV_EVENT_SRQ_ERR: u32 = 14u32;
pub const IBV_EVENT_SRQ_LIMIT_REACHED: u32 = 15u32;
pub const IBV_EVENT_WQ_FATAL: u32 = 19u32;
pub const IBV_FLOW_ACTION_ESP_MASK_ESN: u32 = 1u32;
pub const IBV_FLOW_ATTR_ALL_DEFAULT: u32 = 1u32;
pub const IBV_FLOW_ATTR_FLAGS_DONT_TRAP: u32 = 2u32;
pub const IBV_FLOW_ATTR_FLAGS_EGRESS: u32 = 4u32;
pub const IBV_FLOW_ATTR_MC_DEFAULT: u32 = 2u32;
pub const IBV_FLOW_ATTR_NORMAL: u32 = 0u32;
pub const IBV_FLOW_ATTR_SNIFFER: u32 = 3u32;
pub const IBV_FLOW_SPEC_ACTION_COUNT: u32 = 4099u32;
pub const IBV_FLOW_SPEC_ACTION_DROP: u32 = 4097u32;
pub const IBV_FLOW_SPEC_ACTION_HANDLE: u32 = 4098u32;
pub const IBV_FLOW_SPEC_ACTION_TAG: u32 = 4096u32;
pub const IBV_FLOW_SPEC_ESP: u32 = 52u32;
pub const IBV_FLOW_SPEC_ETH: u32 = 32u32;
pub const IBV_FLOW_SPEC_GRE: u32 = 81u32;
pub const IBV_FLOW_SPEC_INNER: u32 = 256u32;
pub const IBV_FLOW_SPEC_IPV4: u32 = 48u32;
pub const IBV_FLOW_SPEC_IPV4_EXT: u32 = 50u32;
pub const IBV_FLOW_SPEC_IPV6: u32 = 49u32;
pub const IBV_FLOW_SPEC_MPLS: u32 = 96u32;
pub const IBV_FLOW_SPEC_TCP: u32 = 64u32;
pub const IBV_FLOW_SPEC_UDP: u32 = 65u32;
pub const IBV_FLOW_SPEC_VXLAN_TUNNEL: u32 = 80u32;
pub const IBV_FLUSH_GLOBAL: u32 = 1u32;
pub const IBV_FLUSH_MR: u32 = 1u32;
pub const IBV_FLUSH_PERSISTENT: u32 = 2u32;
pub const IBV_FLUSH_RANGE: u32 = 0u32;
pub const IBV_FORK_DISABLED: u32 = 0u32;
pub const IBV_FORK_ENABLED: u32 = 1u32;
pub const IBV_FORK_UNNEEDED: u32 = 2u32;
pub const IBV_GID_TYPE_IB: u32 = 0u32;
pub const IBV_GID_TYPE_ROCE_V1: u32 = 1u32;
pub const IBV_GID_TYPE_ROCE_V2: u32 = 2u32;
pub const IBV_LINK_LAYER_ETHERNET: u32 = 2u32;
pub const IBV_LINK_LAYER_INFINIBAND: u32 = 1u32;
pub const IBV_LINK_LAYER_UNSPECIFIED: u32 = 0u32;
pub const IBV_MIG_ARMED: u32 = 2u32;
pub const IBV_MIG_MIGRATED: u32 = 0u32;
pub const IBV_MIG_REARM: u32 = 1u32;
pub const IBV_MTU_1024: u32 = 3u32;
pub const IBV_MTU_2048: u32 = 4u32;
pub const IBV_MTU_256: u32 = 1u32;
pub const IBV_MTU_4096: u32 = 5u32;
pub const IBV_MTU_512: u32 = 2u32;
pub const IBV_MW_TYPE_1: u32 = 1u32;
pub const IBV_MW_TYPE_2: u32 = 2u32;
pub const IBV_NODE_CA: i32 = 1i32;
pub const IBV_NODE_RNIC: i32 = 4i32;
pub const IBV_NODE_ROUTER: i32 = 3i32;
pub const IBV_NODE_SWITCH: i32 = 2i32;
pub const IBV_NODE_UNKNOWN: i32 = -1i32;
pub const IBV_NODE_UNSPECIFIED: i32 = 7i32;
pub const IBV_NODE_USNIC: i32 = 5i32;
pub const IBV_NODE_USNIC_UDP: i32 = 6i32;
pub const IBV_ODP_SUPPORT: u32 = 1u32;
pub const IBV_ODP_SUPPORT_ATOMIC: u32 = 16u32;
pub const IBV_ODP_SUPPORT_IMPLICIT: u32 = 2u32;
pub const IBV_ODP_SUPPORT_READ: u32 = 8u32;
pub const IBV_ODP_SUPPORT_RECV: u32 = 2u32;
pub const IBV_ODP_SUPPORT_SEND: u32 = 1u32;
pub const IBV_ODP_SUPPORT_SRQ_RECV: u32 = 32u32;
pub const IBV_ODP_SUPPORT_WRITE: u32 = 4u32;
pub const IBV_OPS_SIGNALED: u32 = 1u32;
pub const IBV_OPS_TM_SYNC: u32 = 2u32;
pub const IBV_PARENT_DOMAIN_INIT_ATTR_ALLOCATORS: u32 = 1u32;
pub const IBV_PARENT_DOMAIN_INIT_ATTR_PD_CONTEXT: u32 = 2u32;
pub const IBV_PCI_ATOMIC_OPERATION_16_BYTE_SIZE_SUP: u32 = 4u32;
pub const IBV_PCI_ATOMIC_OPERATION_4_BYTE_SIZE_SUP: u32 = 1u32;
pub const IBV_PCI_ATOMIC_OPERATION_8_BYTE_SIZE_SUP: u32 = 2u32;
pub const IBV_PORT_ACTIVE: u32 = 4u32;
pub const IBV_PORT_ACTIVE_DEFER: u32 = 5u32;
pub const IBV_PORT_ARMED: u32 = 3u32;
pub const IBV_PORT_AUTO_MIGR_SUP: u32 = 32u32;
pub const IBV_PORT_BOOT_MGMT_SUP: u32 = 8388608u32;
pub const IBV_PORT_CAP_MASK2_SUP: u32 = 32768u32;
pub const IBV_PORT_CAP_MASK_NOTICE_SUP: u32 = 4194304u32;
pub const IBV_PORT_CLIENT_REG_SUP: u32 = 33554432u32;
pub const IBV_PORT_CM_SUP: u32 = 65536u32;
pub const IBV_PORT_DEVICE_MGMT_SUP: u32 = 524288u32;
pub const IBV_PORT_DOWN: u32 = 1u32;
pub const IBV_PORT_DR_NOTICE_SUP: u32 = 2097152u32;
pub const IBV_PORT_EXTENDED_SPEEDS_SUP: u32 = 16384u32;
pub const IBV_PORT_INFO_EXT_SUP: u32 = 2u32;
pub const IBV_PORT_INIT: u32 = 2u32;
pub const IBV_PORT_IP_BASED_GIDS: u32 = 67108864u32;
pub const IBV_PORT_LED_INFO_SUP: u32 = 512u32;
pub const IBV_PORT_LINK_LATENCY_SUP: u32 = 16777216u32;
pub const IBV_PORT_LINK_SPEED_HDR_SUP: u32 = 32u32;
pub const IBV_PORT_LINK_SPEED_NDR_SUP: u32 = 1024u32;
pub const IBV_PORT_LINK_SPEED_XDR_SUP: u32 = 4096u32;
pub const IBV_PORT_LINK_WIDTH_2X_SUP: u32 = 16u32;
pub const IBV_PORT_MKEY_NVRAM: u32 = 128u32;
pub const IBV_PORT_NOP: u32 = 0u32;
pub const IBV_PORT_NOTICE_SUP: u32 = 4u32;
pub const IBV_PORT_OPT_IPD_SUP: u32 = 16u32;
pub const IBV_PORT_PKEY_NVRAM: u32 = 256u32;
pub const IBV_PORT_PKEY_SW_EXT_PORT_TRAP_SUP: u32 = 4096u32;
pub const IBV_PORT_REINIT_SUP: u32 = 262144u32;
pub const IBV_PORT_SET_NODE_DESC_SUP: u32 = 1u32;
pub const IBV_PORT_SL_MAP_SUP: u32 = 64u32;
pub const IBV_PORT_SM: u32 = 2u32;
pub const IBV_PORT_SNMP_TUNNEL_SUP: u32 = 131072u32;
pub const IBV_PORT_SWITCH_PORT_STATE_TABLE_SUP: u32 = 8u32;
pub const IBV_PORT_SYS_IMAGE_GUID_SUP: u32 = 2048u32;
pub const IBV_PORT_TRAP_SUP: u32 = 8u32;
pub const IBV_PORT_VENDOR_CLASS_SUP: u32 = 1048576u32;
pub const IBV_PORT_VIRT_SUP: u32 = 4u32;
pub const IBV_QPS_ERR: u32 = 6u32;
pub const IBV_QPS_INIT: u32 = 1u32;
pub const IBV_QPS_RESET: u32 = 0u32;
pub const IBV_QPS_RTR: u32 = 2u32;
pub const IBV_QPS_RTS: u32 = 3u32;
pub const IBV_QPS_SQD: u32 = 4u32;
pub const IBV_QPS_SQE: u32 = 5u32;
pub const IBV_QPS_UNKNOWN: u32 = 7u32;
pub const IBV_QPT_DRIVER: u32 = 255u32;
pub const IBV_QPT_RAW_PACKET: u32 = 8u32;
pub const IBV_QPT_RC: u32 = 2u32;
pub const IBV_QPT_UC: u32 = 3u32;
pub const IBV_QPT_UD: u32 = 4u32;
pub const IBV_QPT_XRC_RECV: u32 = 10u32;
pub const IBV_QPT_XRC_SEND: u32 = 9u32;
pub const IBV_QP_ACCESS_FLAGS: u32 = 8u32;
pub const IBV_QP_ALT_PATH: u32 = 16384u32;
pub const IBV_QP_AV: u32 = 128u32;
pub const IBV_QP_CAP: u32 = 524288u32;
pub const IBV_QP_CREATE_BLOCK_SELF_MCAST_LB: u32 = 2u32;
pub const IBV_QP_CREATE_CVLAN_STRIPPING: u32 = 512u32;
pub const IBV_QP_CREATE_PCI_WRITE_END_PADDING: u32 = 2048u32;
pub const IBV_QP_CREATE_SCATTER_FCS: u32 = 256u32;
pub const IBV_QP_CREATE_SOURCE_QPN: u32 = 1024u32;
pub const IBV_QP_CUR_STATE: u32 = 2u32;
pub const IBV_QP_DEST_QPN: u32 = 1048576u32;
pub const IBV_QP_EN_SQD_ASYNC_NOTIFY: u32 = 4u32;
pub const IBV_QP_EX_WITH_ATOMIC_CMP_AND_SWP: u32 = 32u32;
pub const IBV_QP_EX_WITH_ATOMIC_FETCH_AND_ADD: u32 = 64u32;
pub const IBV_QP_EX_WITH_ATOMIC_WRITE: u32 = 4096u32;
pub const IBV_QP_EX_WITH_BIND_MW: u32 = 256u32;
pub const IBV_QP_EX_WITH_FLUSH: u32 = 2048u32;
pub const IBV_QP_EX_WITH_LOCAL_INV: u32 = 128u32;
pub const IBV_QP_EX_WITH_RDMA_READ: u32 = 16u32;
pub const IBV_QP_EX_WITH_RDMA_WRITE: u32 = 1u32;
pub const IBV_QP_EX_WITH_RDMA_WRITE_WITH_IMM: u32 = 2u32;
pub const IBV_QP_EX_WITH_SEND: u32 = 4u32;
pub const IBV_QP_EX_WITH_SEND_WITH_IMM: u32 = 8u32;
pub const IBV_QP_EX_WITH_SEND_WITH_INV: u32 = 512u32;
pub const IBV_QP_EX_WITH_TSO: u32 = 1024u32;
pub const IBV_QP_INIT_ATTR_CREATE_FLAGS: u32 = 4u32;
pub const IBV_QP_INIT_ATTR_IND_TABLE: u32 = 16u32;
pub const IBV_QP_INIT_ATTR_MAX_TSO_HEADER: u32 = 8u32;
pub const IBV_QP_INIT_ATTR_PD: u32 = 1u32;
pub const IBV_QP_INIT_ATTR_RX_HASH: u32 = 32u32;
pub const IBV_QP_INIT_ATTR_SEND_OPS_FLAGS: u32 = 64u32;
pub const IBV_QP_INIT_ATTR_XRCD: u32 = 2u32;
pub const IBV_QP_MAX_DEST_RD_ATOMIC: u32 = 131072u32;
pub const IBV_QP_MAX_QP_RD_ATOMIC: u32 = 8192u32;
pub const IBV_QP_MIN_RNR_TIMER: u32 = 32768u32;
pub const IBV_QP_OPEN_ATTR_CONTEXT: u32 = 4u32;
pub const IBV_QP_OPEN_ATTR_NUM: u32 = 1u32;
pub const IBV_QP_OPEN_ATTR_RESERVED: u32 = 16u32;
pub const IBV_QP_OPEN_ATTR_TYPE: u32 = 8u32;
pub const IBV_QP_OPEN_ATTR_XRCD: u32 = 2u32;
pub const IBV_QP_PATH_MIG_STATE: u32 = 262144u32;
pub const IBV_QP_PATH_MTU: u32 = 256u32;
pub const IBV_QP_PKEY_INDEX: u32 = 16u32;
pub const IBV_QP_PORT: u32 = 32u32;
pub const IBV_QP_QKEY: u32 = 64u32;
pub const IBV_QP_RATE_LIMIT: u32 = 33554432u32;
pub const IBV_QP_RETRY_CNT: u32 = 1024u32;
pub const IBV_QP_RNR_RETRY: u32 = 2048u32;
pub const IBV_QP_RQ_PSN: u32 = 4096u32;
pub const IBV_QP_SQ_PSN: u32 = 65536u32;
pub const IBV_QP_STATE: u32 = 1u32;
pub const IBV_QP_TIMEOUT: u32 = 512u32;
pub const IBV_QUERY_QP_DATA_IN_ORDER_ALIGNED_128_BYTES: u32 = 2u32;
pub const IBV_QUERY_QP_DATA_IN_ORDER_RETURN_CAPS: u32 = 1u32;
pub const IBV_QUERY_QP_DATA_IN_ORDER_WHOLE_MSG: u32 = 1u32;
pub const IBV_RATE_100_GBPS: u32 = 16u32;
pub const IBV_RATE_10_GBPS: u32 = 3u32;
pub const IBV_RATE_112_GBPS: u32 = 13u32;
pub const IBV_RATE_1200_GBPS: u32 = 24u32;
pub const IBV_RATE_120_GBPS: u32 = 10u32;
pub const IBV_RATE_14_GBPS: u32 = 11u32;
pub const IBV_RATE_168_GBPS: u32 = 14u32;
pub const IBV_RATE_200_GBPS: u32 = 17u32;
pub const IBV_RATE_20_GBPS: u32 = 6u32;
pub const IBV_RATE_25_GBPS: u32 = 15u32;
pub const IBV_RATE_28_GBPS: u32 = 19u32;
pub const IBV_RATE_2_5_GBPS: u32 = 2u32;
pub const IBV_RATE_300_GBPS: u32 = 18u32;
pub const IBV_RATE_30_GBPS: u32 = 4u32;
pub const IBV_RATE_400_GBPS: u32 = 21u32;
pub const IBV_RATE_40_GBPS: u32 = 7u32;
pub const IBV_RATE_50_GBPS: u32 = 20u32;
pub const IBV_RATE_56_GBPS: u32 = 12u32;
pub const IBV_RATE_5_GBPS: u32 = 5u32;
pub const IBV_RATE_600_GBPS: u32 = 22u32;
pub const IBV_RATE_60_GBPS: u32 = 8u32;
pub const IBV_RATE_800_GBPS: u32 = 23u32;
pub const IBV_RATE_80_GBPS: u32 = 9u32;
pub const IBV_RATE_MAX: u32 = 0u32;
pub const IBV_RAW_PACKET_CAP_CVLAN_STRIPPING: u32 = 1u32;
pub const IBV_RAW_PACKET_CAP_DELAY_DROP: u32 = 8u32;
pub const IBV_RAW_PACKET_CAP_IP_CSUM: u32 = 4u32;
pub const IBV_RAW_PACKET_CAP_SCATTER_FCS: u32 = 2u32;
pub const IBV_READ_COUNTERS_ATTR_PREFER_CACHED: u32 = 1u32;
pub const IBV_REREG_MR_CHANGE_ACCESS: u32 = 4u32;
pub const IBV_REREG_MR_CHANGE_PD: u32 = 2u32;
pub const IBV_REREG_MR_CHANGE_TRANSLATION: u32 = 1u32;
pub const IBV_REREG_MR_ERR_CMD: i32 = -4i32;
pub const IBV_REREG_MR_ERR_CMD_AND_DO_FORK_NEW: i32 = -5i32;
pub const IBV_REREG_MR_ERR_DONT_FORK_NEW: i32 = -2i32;
pub const IBV_REREG_MR_ERR_DO_FORK_OLD: i32 = -3i32;
pub const IBV_REREG_MR_ERR_INPUT: i32 = -1i32;
pub const IBV_REREG_MR_FLAGS_SUPPORTED: u32 = 7u32;
pub const IBV_RX_HASH_DST_IPV4: u32 = 2u32;
pub const IBV_RX_HASH_DST_IPV6: u32 = 8u32;
pub const IBV_RX_HASH_DST_PORT_TCP: u32 = 32u32;
pub const IBV_RX_HASH_DST_PORT_UDP: u32 = 128u32;
pub const IBV_RX_HASH_FUNC_TOEPLITZ: u32 = 1u32;
pub const IBV_RX_HASH_INNER: u32 = 2147483648u32;
pub const IBV_RX_HASH_IPSEC_SPI: u32 = 256u32;
pub const IBV_RX_HASH_SRC_IPV4: u32 = 1u32;
pub const IBV_RX_HASH_SRC_IPV6: u32 = 4u32;
pub const IBV_RX_HASH_SRC_PORT_TCP: u32 = 16u32;
pub const IBV_RX_HASH_SRC_PORT_UDP: u32 = 64u32;
pub const IBV_SEND_FENCE: u32 = 1u32;
pub const IBV_SEND_INLINE: u32 = 8u32;
pub const IBV_SEND_IP_CSUM: u32 = 16u32;
pub const IBV_SEND_SIGNALED: u32 = 2u32;
pub const IBV_SEND_SOLICITED: u32 = 4u32;
pub const IBV_SRQT_BASIC: u32 = 0u32;
pub const IBV_SRQT_TM: u32 = 2u32;
pub const IBV_SRQT_XRC: u32 = 1u32;
pub const IBV_SRQ_INIT_ATTR_CQ: u32 = 8u32;
pub const IBV_SRQ_INIT_ATTR_PD: u32 = 2u32;
pub const IBV_SRQ_INIT_ATTR_RESERVED: u32 = 32u32;
pub const IBV_SRQ_INIT_ATTR_TM: u32 = 16u32;
pub const IBV_SRQ_INIT_ATTR_TYPE: u32 = 1u32;
pub const IBV_SRQ_INIT_ATTR_XRCD: u32 = 4u32;
pub const IBV_SRQ_LIMIT: u32 = 2u32;
pub const IBV_SRQ_MAX_WR: u32 = 1u32;
pub const IBV_SYSFS_NAME_MAX: u32 = 64u32;
pub const IBV_SYSFS_PATH_MAX: u32 = 256u32;
pub const IBV_TM_CAP_RC: u32 = 1u32;
pub const IBV_TRANSPORT_IB: i32 = 0i32;
pub const IBV_TRANSPORT_IWARP: i32 = 1i32;
pub const IBV_TRANSPORT_UNKNOWN: i32 = -1i32;
pub const IBV_TRANSPORT_UNSPECIFIED: i32 = 4i32;
pub const IBV_TRANSPORT_USNIC: i32 = 2i32;
pub const IBV_TRANSPORT_USNIC_UDP: i32 = 3i32;
pub const IBV_VALUES_MASK_RAW_CLOCK: u32 = 1u32;
pub const IBV_VALUES_MASK_RESERVED: u32 = 2u32;
pub const IBV_WC_ATOMIC_WRITE: u32 = 9u32;
pub const IBV_WC_BAD_RESP_ERR: u32 = 7u32;
pub const IBV_WC_BIND_MW: u32 = 5u32;
pub const IBV_WC_COMP_SWAP: u32 = 3u32;
pub const IBV_WC_DRIVER1: u32 = 135u32;
pub const IBV_WC_DRIVER2: u32 = 136u32;
pub const IBV_WC_DRIVER3: u32 = 137u32;
pub const IBV_WC_EX_WITH_BYTE_LEN: u32 = 1u32;
pub const IBV_WC_EX_WITH_COMPLETION_TIMESTAMP: u32 = 128u32;
pub const IBV_WC_EX_WITH_COMPLETION_TIMESTAMP_WALLCLOCK: u32 = 2048u32;
pub const IBV_WC_EX_WITH_CVLAN: u32 = 256u32;
pub const IBV_WC_EX_WITH_DLID_PATH_BITS: u32 = 64u32;
pub const IBV_WC_EX_WITH_FLOW_TAG: u32 = 512u32;
pub const IBV_WC_EX_WITH_IMM: u32 = 2u32;
pub const IBV_WC_EX_WITH_QP_NUM: u32 = 4u32;
pub const IBV_WC_EX_WITH_SL: u32 = 32u32;
pub const IBV_WC_EX_WITH_SLID: u32 = 16u32;
pub const IBV_WC_EX_WITH_SRC_QP: u32 = 8u32;
pub const IBV_WC_EX_WITH_TM_INFO: u32 = 1024u32;
pub const IBV_WC_FATAL_ERR: u32 = 19u32;
pub const IBV_WC_FETCH_ADD: u32 = 4u32;
pub const IBV_WC_FLUSH: u32 = 8u32;
pub const IBV_WC_GENERAL_ERR: u32 = 21u32;
pub const IBV_WC_GRH: u32 = 1u32;
pub const IBV_WC_INV_EECN_ERR: u32 = 17u32;
pub const IBV_WC_INV_EEC_STATE_ERR: u32 = 18u32;
pub const IBV_WC_IP_CSUM_OK: u32 = 4u32;
pub const IBV_WC_IP_CSUM_OK_SHIFT: u32 = 2u32;
pub const IBV_WC_LOCAL_INV: u32 = 6u32;
pub const IBV_WC_LOC_ACCESS_ERR: u32 = 8u32;
pub const IBV_WC_LOC_EEC_OP_ERR: u32 = 3u32;
pub const IBV_WC_LOC_LEN_ERR: u32 = 1u32;
pub const IBV_WC_LOC_PROT_ERR: u32 = 4u32;
pub const IBV_WC_LOC_QP_OP_ERR: u32 = 2u32;
pub const IBV_WC_LOC_RDD_VIOL_ERR: u32 = 14u32;
pub const IBV_WC_MW_BIND_ERR: u32 = 6u32;
pub const IBV_WC_RDMA_READ: u32 = 2u32;
pub const IBV_WC_RDMA_WRITE: u32 = 1u32;
pub const IBV_WC_RECV: u32 = 128u32;
pub const IBV_WC_RECV_RDMA_WITH_IMM: u32 = 129u32;
pub const IBV_WC_REM_ABORT_ERR: u32 = 16u32;
pub const IBV_WC_REM_ACCESS_ERR: u32 = 10u32;
pub const IBV_WC_REM_INV_RD_REQ_ERR: u32 = 15u32;
pub const IBV_WC_REM_INV_REQ_ERR: u32 = 9u32;
pub const IBV_WC_REM_OP_ERR: u32 = 11u32;
pub const IBV_WC_RESP_TIMEOUT_ERR: u32 = 20u32;
pub const IBV_WC_RETRY_EXC_ERR: u32 = 12u32;
pub const IBV_WC_RNR_RETRY_EXC_ERR: u32 = 13u32;
pub const IBV_WC_SEND: u32 = 0u32;
pub const IBV_WC_STANDARD_FLAGS: u32 = 127u32;
pub const IBV_WC_SUCCESS: u32 = 0u32;
pub const IBV_WC_TM_ADD: u32 = 130u32;
pub const IBV_WC_TM_DATA_VALID: u32 = 64u32;
pub const IBV_WC_TM_DEL: u32 = 131u32;
pub const IBV_WC_TM_ERR: u32 = 22u32;
pub const IBV_WC_TM_MATCH: u32 = 32u32;
pub const IBV_WC_TM_NO_TAG: u32 = 134u32;
pub const IBV_WC_TM_RECV: u32 = 133u32;
pub const IBV_WC_TM_RNDV_INCOMPLETE: u32 = 23u32;
pub const IBV_WC_TM_SYNC: u32 = 132u32;
pub const IBV_WC_TM_SYNC_REQ: u32 = 16u32;
pub const IBV_WC_TSO: u32 = 7u32;
pub const IBV_WC_WITH_IMM: u32 = 2u32;
pub const IBV_WC_WITH_INV: u32 = 8u32;
pub const IBV_WC_WR_FLUSH_ERR: u32 = 5u32;
pub const IBV_WQS_ERR: u32 = 2u32;
pub const IBV_WQS_RDY: u32 = 1u32;
pub const IBV_WQS_RESET: u32 = 0u32;
pub const IBV_WQS_UNKNOWN: u32 = 3u32;
pub const IBV_WQT_RQ: u32 = 0u32;
pub const IBV_WQ_ATTR_CURR_STATE: u32 = 2u32;
pub const IBV_WQ_ATTR_FLAGS: u32 = 4u32;
pub const IBV_WQ_ATTR_RESERVED: u32 = 8u32;
pub const IBV_WQ_ATTR_STATE: u32 = 1u32;
pub const IBV_WQ_FLAGS_CVLAN_STRIPPING: u32 = 1u32;
pub const IBV_WQ_FLAGS_DELAY_DROP: u32 = 4u32;
pub const IBV_WQ_FLAGS_PCI_WRITE_END_PADDING: u32 = 8u32;
pub const IBV_WQ_FLAGS_RESERVED: u32 = 16u32;
pub const IBV_WQ_FLAGS_SCATTER_FCS: u32 = 2u32;
pub const IBV_WQ_INIT_ATTR_FLAGS: u32 = 1u32;
pub const IBV_WQ_INIT_ATTR_RESERVED: u32 = 2u32;
pub const IBV_WR_ATOMIC_CMP_AND_SWP: u32 = 5u32;
pub const IBV_WR_ATOMIC_FETCH_AND_ADD: u32 = 6u32;
pub const IBV_WR_ATOMIC_WRITE: u32 = 15u32;
pub const IBV_WR_BIND_MW: u32 = 8u32;
pub const IBV_WR_DRIVER1: u32 = 11u32;
pub const IBV_WR_FLUSH: u32 = 14u32;
pub const IBV_WR_LOCAL_INV: u32 = 7u32;
pub const IBV_WR_RDMA_READ: u32 = 4u32;
pub const IBV_WR_RDMA_WRITE: u32 = 0u32;
pub const IBV_WR_RDMA_WRITE_WITH_IMM: u32 = 1u32;
pub const IBV_WR_SEND: u32 = 2u32;
pub const IBV_WR_SEND_WITH_IMM: u32 = 3u32;
pub const IBV_WR_SEND_WITH_INV: u32 = 9u32;
pub const IBV_WR_TAG_ADD: u32 = 0u32;
pub const IBV_WR_TAG_DEL: u32 = 1u32;
pub const IBV_WR_TAG_SYNC: u32 = 2u32;
pub const IBV_WR_TSO: u32 = 10u32;
pub const IBV_XRCD_INIT_ATTR_FD: u32 = 1u32;
pub const IBV_XRCD_INIT_ATTR_OFLAGS: u32 = 2u32;
pub const IBV_XRCD_INIT_ATTR_RESERVED: u32 = 4u32;
pub const IB_DEVICE_NAME_MAX: i32 = 64i32;
pub const IB_FLUSH_GLOBAL: u32 = 1u32;
pub const IB_FLUSH_MR: u32 = 1u32;
pub const IB_FLUSH_PERSISTENT: u32 = 2u32;
pub const IB_FLUSH_RANGE: u32 = 0u32;
pub const IB_USER_VERBS_ABI_VERSION: i32 = 6i32;
pub const IB_USER_VERBS_CMD_ALLOC_MW: u32 = 14u32;
pub const IB_USER_VERBS_CMD_ALLOC_PD: u32 = 3u32;
pub const IB_USER_VERBS_CMD_ATTACH_MCAST: u32 = 30u32;
pub const IB_USER_VERBS_CMD_BIND_MW: u32 = 15u32;
pub const IB_USER_VERBS_CMD_CLOSE_XRCD: u32 = 38u32;
pub const IB_USER_VERBS_CMD_COMMAND_MASK: i32 = 255i32;
pub const IB_USER_VERBS_CMD_CREATE_AH: u32 = 5u32;
pub const IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL: u32 = 17u32;
pub const IB_USER_VERBS_CMD_CREATE_CQ: u32 = 18u32;
pub const IB_USER_VERBS_CMD_CREATE_QP: u32 = 24u32;
pub const IB_USER_VERBS_CMD_CREATE_SRQ: u32 = 32u32;
pub const IB_USER_VERBS_CMD_CREATE_XSRQ: u32 = 39u32;
pub const IB_USER_VERBS_CMD_DEALLOC_MW: u32 = 16u32;
pub const IB_USER_VERBS_CMD_DEALLOC_PD: u32 = 4u32;
pub const IB_USER_VERBS_CMD_DEREG_MR: u32 = 13u32;
pub const IB_USER_VERBS_CMD_DESTROY_AH: u32 = 8u32;
pub const IB_USER_VERBS_CMD_DESTROY_CQ: u32 = 20u32;
pub const IB_USER_VERBS_CMD_DESTROY_QP: u32 = 27u32;
pub const IB_USER_VERBS_CMD_DESTROY_SRQ: u32 = 35u32;
pub const IB_USER_VERBS_CMD_DETACH_MCAST: u32 = 31u32;
pub const IB_USER_VERBS_CMD_FLAG_EXTENDED: i32 = -2147483648i32;
pub const IB_USER_VERBS_CMD_GET_CONTEXT: u32 = 0u32;
pub const IB_USER_VERBS_CMD_MODIFY_AH: u32 = 6u32;
pub const IB_USER_VERBS_CMD_MODIFY_QP: u32 = 26u32;
pub const IB_USER_VERBS_CMD_MODIFY_SRQ: u32 = 33u32;
pub const IB_USER_VERBS_CMD_OPEN_QP: u32 = 40u32;
pub const IB_USER_VERBS_CMD_OPEN_XRCD: u32 = 37u32;
pub const IB_USER_VERBS_CMD_PEEK_CQ: u32 = 22u32;
pub const IB_USER_VERBS_CMD_POLL_CQ: u32 = 21u32;
pub const IB_USER_VERBS_CMD_POST_RECV: u32 = 29u32;
pub const IB_USER_VERBS_CMD_POST_SEND: u32 = 28u32;
pub const IB_USER_VERBS_CMD_POST_SRQ_RECV: u32 = 36u32;
pub const IB_USER_VERBS_CMD_QUERY_AH: u32 = 7u32;
pub const IB_USER_VERBS_CMD_QUERY_DEVICE: u32 = 1u32;
pub const IB_USER_VERBS_CMD_QUERY_MR: u32 = 12u32;
pub const IB_USER_VERBS_CMD_QUERY_PORT: u32 = 2u32;
pub const IB_USER_VERBS_CMD_QUERY_QP: u32 = 25u32;
pub const IB_USER_VERBS_CMD_QUERY_SRQ: u32 = 34u32;
pub const IB_USER_VERBS_CMD_REG_MR: u32 = 9u32;
pub const IB_USER_VERBS_CMD_REG_SMR: u32 = 10u32;
pub const IB_USER_VERBS_CMD_REQ_NOTIFY_CQ: u32 = 23u32;
pub const IB_USER_VERBS_CMD_REREG_MR: u32 = 11u32;
pub const IB_USER_VERBS_CMD_RESIZE_CQ: u32 = 19u32;
pub const IB_USER_VERBS_CMD_THRESHOLD: i32 = 50i32;
pub const IB_USER_VERBS_EX_CMD_CREATE_CQ: u32 = 18u32;
pub const IB_USER_VERBS_EX_CMD_CREATE_FLOW: u32 = 50u32;
pub const IB_USER_VERBS_EX_CMD_CREATE_QP: u32 = 24u32;
pub const IB_USER_VERBS_EX_CMD_CREATE_RWQ_IND_TBL: u32 = 55u32;
pub const IB_USER_VERBS_EX_CMD_CREATE_WQ: u32 = 52u32;
pub const IB_USER_VERBS_EX_CMD_DESTROY_FLOW: u32 = 51u32;
pub const IB_USER_VERBS_EX_CMD_DESTROY_RWQ_IND_TBL: u32 = 56u32;
pub const IB_USER_VERBS_EX_CMD_DESTROY_WQ: u32 = 54u32;
pub const IB_USER_VERBS_EX_CMD_MODIFY_CQ: u32 = 57u32;
pub const IB_USER_VERBS_EX_CMD_MODIFY_QP: u32 = 26u32;
pub const IB_USER_VERBS_EX_CMD_MODIFY_WQ: u32 = 53u32;
pub const IB_USER_VERBS_EX_CMD_QUERY_DEVICE: u32 = 1u32;
pub const IB_USER_VERBS_MAX_LOG_IND_TBL_SIZE: i32 = 13i32;
pub const IB_UVERBS_ACCESS_FLUSH_GLOBAL: u32 = 256u32;
pub const IB_UVERBS_ACCESS_FLUSH_PERSISTENT: u32 = 512u32;
pub const IB_UVERBS_ACCESS_HUGETLB: u32 = 128u32;
pub const IB_UVERBS_ACCESS_LOCAL_WRITE: u32 = 1u32;
pub const IB_UVERBS_ACCESS_MW_BIND: u32 = 16u32;
pub const IB_UVERBS_ACCESS_ON_DEMAND: u32 = 64u32;
pub const IB_UVERBS_ACCESS_OPTIONAL_RANGE: u32 = 1072693248u32;
pub const IB_UVERBS_ACCESS_RELAXED_ORDERING: u32 = 1048576u32;
pub const IB_UVERBS_ACCESS_REMOTE_ATOMIC: u32 = 8u32;
pub const IB_UVERBS_ACCESS_REMOTE_READ: u32 = 4u32;
pub const IB_UVERBS_ACCESS_REMOTE_WRITE: u32 = 2u32;
pub const IB_UVERBS_ACCESS_ZERO_BASED: u32 = 32u32;
pub const IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH: u32 = 0u32;
pub const IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT: u32 = 2u32;
pub const IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE: u32 = 1u32;
pub const IB_UVERBS_ADVISE_MR_FLAG_FLUSH: u32 = 1u32;
pub const IB_UVERBS_CORE_SUPPORT_OPTIONAL_MR_ACCESS: u32 = 1u32;
pub const IB_UVERBS_CQ_FLAGS_IGNORE_OVERRUN: u32 = 2u32;
pub const IB_UVERBS_CQ_FLAGS_TIMESTAMP_COMPLETION: u32 = 1u32;
pub const IB_UVERBS_CREATE_QP_MASK_IND_TABLE: u32 = 1u32;
pub const IB_UVERBS_CREATE_QP_SUP_COMP_MASK: u32 = 1u32;
pub const IB_UVERBS_DEVICE_ATOMIC_WRITE: u64 = 1099511627776u64;
pub const IB_UVERBS_DEVICE_AUTO_PATH_MIG: u64 = 16u64;
pub const IB_UVERBS_DEVICE_BAD_PKEY_CNTR: u64 = 2u64;
pub const IB_UVERBS_DEVICE_BAD_QKEY_CNTR: u64 = 4u64;
pub const IB_UVERBS_DEVICE_CHANGE_PHY_PORT: u64 = 32u64;
pub const IB_UVERBS_DEVICE_CURR_QP_STATE_MOD: u64 = 128u64;
pub const IB_UVERBS_DEVICE_FLUSH_GLOBAL: u64 = 274877906944u64;
pub const IB_UVERBS_DEVICE_FLUSH_PERSISTENT: u64 = 549755813888u64;
pub const IB_UVERBS_DEVICE_MANAGED_FLOW_STEERING: u64 = 536870912u64;
pub const IB_UVERBS_DEVICE_MEM_MGT_EXTENSIONS: u64 = 2097152u64;
pub const IB_UVERBS_DEVICE_MEM_WINDOW: u64 = 131072u64;
pub const IB_UVERBS_DEVICE_MEM_WINDOW_TYPE_2A: u64 = 8388608u64;
pub const IB_UVERBS_DEVICE_MEM_WINDOW_TYPE_2B: u64 = 16777216u64;
pub const IB_UVERBS_DEVICE_N_NOTIFY_CQ: u64 = 16384u64;
pub const IB_UVERBS_DEVICE_PCI_WRITE_END_PADDING: u64 = 68719476736u64;
pub const IB_UVERBS_DEVICE_PORT_ACTIVE_EVENT: u64 = 1024u64;
pub const IB_UVERBS_DEVICE_RAW_IP_CSUM: u64 = 67108864u64;
pub const IB_UVERBS_DEVICE_RAW_MULTI: u64 = 8u64;
pub const IB_UVERBS_DEVICE_RAW_SCATTER_FCS: u64 = 17179869184u64;
pub const IB_UVERBS_DEVICE_RC_IP_CSUM: u64 = 33554432u64;
pub const IB_UVERBS_DEVICE_RC_RNR_NAK_GEN: u64 = 4096u64;
pub const IB_UVERBS_DEVICE_RESIZE_MAX_WR: u64 = 1u64;
pub const IB_UVERBS_DEVICE_SHUTDOWN_PORT: u64 = 256u64;
pub const IB_UVERBS_DEVICE_SRQ_RESIZE: u64 = 8192u64;
pub const IB_UVERBS_DEVICE_SYS_IMAGE_GUID: u64 = 2048u64;
pub const IB_UVERBS_DEVICE_UD_AV_PORT_ENFORCE: u64 = 64u64;
pub const IB_UVERBS_DEVICE_UD_IP_CSUM: u64 = 262144u64;
pub const IB_UVERBS_DEVICE_XRC: u64 = 1048576u64;
pub const IB_UVERBS_FLOW_ACTION_ESP_FLAGS_DECRYPT: u32 = 0u32;
pub const IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ENCRYPT: u32 = 4u32;
pub const IB_UVERBS_FLOW_ACTION_ESP_FLAGS_ESN_NEW_WINDOW: u32 = 8u32;
pub const IB_UVERBS_FLOW_ACTION_ESP_FLAGS_FULL_OFFLOAD: u32 = 1u32;
pub const IB_UVERBS_FLOW_ACTION_ESP_FLAGS_INLINE_CRYPTO: u32 = 0u32;
pub const IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TRANSPORT: u32 = 2u32;
pub const IB_UVERBS_FLOW_ACTION_ESP_FLAGS_TUNNEL: u32 = 0u32;
pub const IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM: u32 = 0u32;
pub const IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP: u32 = 1u32;
pub const IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE: u32 = 0u32;
pub const IB_UVERBS_FLOW_ACTION_IV_ALGO_SEQ: u32 = 0u32;
pub const IB_UVERBS_GID_TYPE_IB: u32 = 0u32;
pub const IB_UVERBS_GID_TYPE_ROCE_V1: u32 = 1u32;
pub const IB_UVERBS_GID_TYPE_ROCE_V2: u32 = 2u32;
pub const IB_UVERBS_PCF_AUTO_MIGR_SUP: u32 = 32u32;
pub const IB_UVERBS_PCF_BOOT_MGMT_SUP: u32 = 8388608u32;
pub const IB_UVERBS_PCF_CAP_MASK_NOTICE_SUP: u32 = 4194304u32;
pub const IB_UVERBS_PCF_CLIENT_REG_SUP: u32 = 33554432u32;
pub const IB_UVERBS_PCF_CM_SUP: u32 = 65536u32;
pub const IB_UVERBS_PCF_DEVICE_MGMT_SUP: u32 = 524288u32;
pub const IB_UVERBS_PCF_DR_NOTICE_SUP: u32 = 2097152u32;
pub const IB_UVERBS_PCF_EXTENDED_SPEEDS_SUP: u32 = 16384u32;
pub const IB_UVERBS_PCF_HIERARCHY_INFO_SUP: u32 = 2147483648u32;
pub const IB_UVERBS_PCF_IP_BASED_GIDS: u32 = 67108864u32;
pub const IB_UVERBS_PCF_LED_INFO_SUP: u32 = 512u32;
pub const IB_UVERBS_PCF_LINK_LATENCY_SUP: u32 = 16777216u32;
pub const IB_UVERBS_PCF_LINK_SPEED_WIDTH_TABLE_SUP: u32 = 134217728u32;
pub const IB_UVERBS_PCF_MCAST_FDB_TOP_SUP: u32 = 1073741824u32;
pub const IB_UVERBS_PCF_MCAST_PKEY_TRAP_SUPPRESSION_SUP: u32 = 536870912u32;
pub const IB_UVERBS_PCF_MKEY_NVRAM: u32 = 128u32;
pub const IB_UVERBS_PCF_NOTICE_SUP: u32 = 4u32;
pub const IB_UVERBS_PCF_OPT_IPD_SUP: u32 = 16u32;
pub const IB_UVERBS_PCF_PKEY_NVRAM: u32 = 256u32;
pub const IB_UVERBS_PCF_PKEY_SW_EXT_PORT_TRAP_SUP: u32 = 4096u32;
pub const IB_UVERBS_PCF_REINIT_SUP: u32 = 262144u32;
pub const IB_UVERBS_PCF_SL_MAP_SUP: u32 = 64u32;
pub const IB_UVERBS_PCF_SM: u32 = 2u32;
pub const IB_UVERBS_PCF_SM_DISABLED: u32 = 1024u32;
pub const IB_UVERBS_PCF_SNMP_TUNNEL_SUP: u32 = 131072u32;
pub const IB_UVERBS_PCF_SYS_IMAGE_GUID_SUP: u32 = 2048u32;
pub const IB_UVERBS_PCF_TRAP_SUP: u32 = 8u32;
pub const IB_UVERBS_PCF_VENDOR_CLASS_SUP: u32 = 1048576u32;
pub const IB_UVERBS_PCF_VENDOR_SPECIFIC_MADS_TABLE_SUP: u32 = 268435456u32;
pub const IB_UVERBS_QPF_GRH_REQUIRED: u32 = 1u32;
pub const IB_UVERBS_QPT_DRIVER: u32 = 255u32;
pub const IB_UVERBS_QPT_RAW_PACKET: u32 = 8u32;
pub const IB_UVERBS_QPT_RC: u32 = 2u32;
pub const IB_UVERBS_QPT_UC: u32 = 3u32;
pub const IB_UVERBS_QPT_UD: u32 = 4u32;
pub const IB_UVERBS_QPT_XRC_INI: u32 = 9u32;
pub const IB_UVERBS_QPT_XRC_TGT: u32 = 10u32;
pub const IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK: u32 = 2u32;
pub const IB_UVERBS_QP_CREATE_CVLAN_STRIPPING: u32 = 512u32;
pub const IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING: u32 = 2048u32;
pub const IB_UVERBS_QP_CREATE_SCATTER_FCS: u32 = 256u32;
pub const IB_UVERBS_QP_CREATE_SQ_SIG_ALL: u32 = 4096u32;
pub const IB_UVERBS_RAW_PACKET_CAP_CVLAN_STRIPPING: u32 = 1u32;
pub const IB_UVERBS_RAW_PACKET_CAP_DELAY_DROP: u32 = 8u32;
pub const IB_UVERBS_RAW_PACKET_CAP_IP_CSUM: u32 = 4u32;
pub const IB_UVERBS_RAW_PACKET_CAP_SCATTER_FCS: u32 = 2u32;
pub const IB_UVERBS_READ_COUNTERS_PREFER_CACHED: u32 = 1u32;
pub const IB_UVERBS_SRQT_BASIC: u32 = 0u32;
pub const IB_UVERBS_SRQT_TM: u32 = 2u32;
pub const IB_UVERBS_SRQT_XRC: u32 = 1u32;
pub const IB_UVERBS_WC_ATOMIC_WRITE: u32 = 9u32;
pub const IB_UVERBS_WC_BIND_MW: u32 = 5u32;
pub const IB_UVERBS_WC_COMP_SWAP: u32 = 3u32;
pub const IB_UVERBS_WC_FETCH_ADD: u32 = 4u32;
pub const IB_UVERBS_WC_FLUSH: u32 = 8u32;
pub const IB_UVERBS_WC_LOCAL_INV: u32 = 6u32;
pub const IB_UVERBS_WC_RDMA_READ: u32 = 2u32;
pub const IB_UVERBS_WC_RDMA_WRITE: u32 = 1u32;
pub const IB_UVERBS_WC_SEND: u32 = 0u32;
pub const IB_UVERBS_WC_TSO: u32 = 7u32;
pub const IB_UVERBS_WQT_RQ: u32 = 0u32;
pub const IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING: u32 = 1u32;
pub const IB_UVERBS_WQ_FLAGS_DELAY_DROP: u32 = 4u32;
pub const IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING: u32 = 8u32;
pub const IB_UVERBS_WQ_FLAGS_SCATTER_FCS: u32 = 2u32;
pub const IB_UVERBS_WR_ATOMIC_CMP_AND_SWP: u32 = 5u32;
pub const IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD: u32 = 6u32;
pub const IB_UVERBS_WR_ATOMIC_WRITE: u32 = 15u32;
pub const IB_UVERBS_WR_BIND_MW: u32 = 8u32;
pub const IB_UVERBS_WR_FLUSH: u32 = 14u32;
pub const IB_UVERBS_WR_LOCAL_INV: u32 = 7u32;
pub const IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP: u32 = 12u32;
pub const IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD: u32 = 13u32;
pub const IB_UVERBS_WR_RDMA_READ: u32 = 4u32;
pub const IB_UVERBS_WR_RDMA_READ_WITH_INV: u32 = 11u32;
pub const IB_UVERBS_WR_RDMA_WRITE: u32 = 0u32;
pub const IB_UVERBS_WR_RDMA_WRITE_WITH_IMM: u32 = 1u32;
pub const IB_UVERBS_WR_SEND: u32 = 2u32;
pub const IB_UVERBS_WR_SEND_WITH_IMM: u32 = 3u32;
pub const IB_UVERBS_WR_SEND_WITH_INV: u32 = 9u32;
pub const IB_UVERBS_WR_TSO: u32 = 10u32;
pub const RDMA_DRIVER_BNXT_RE: u32 = 6u32;
pub const RDMA_DRIVER_CXGB3: u32 = 3u32;
pub const RDMA_DRIVER_CXGB4: u32 = 4u32;
pub const RDMA_DRIVER_EFA: u32 = 17u32;
pub const RDMA_DRIVER_ERDMA: u32 = 19u32;
pub const RDMA_DRIVER_HFI1: u32 = 15u32;
pub const RDMA_DRIVER_HNS: u32 = 12u32;
pub const RDMA_DRIVER_I40IW: u32 = 9u32;
pub const RDMA_DRIVER_IRDMA: u32 = 9u32;
pub const RDMA_DRIVER_MANA: u32 = 20u32;
pub const RDMA_DRIVER_MLX4: u32 = 2u32;
pub const RDMA_DRIVER_MLX5: u32 = 1u32;
pub const RDMA_DRIVER_MTHCA: u32 = 5u32;
pub const RDMA_DRIVER_NES: u32 = 8u32;
pub const RDMA_DRIVER_OCRDMA: u32 = 7u32;
pub const RDMA_DRIVER_QEDR: u32 = 11u32;
pub const RDMA_DRIVER_QIB: u32 = 16u32;
pub const RDMA_DRIVER_RXE: u32 = 14u32;
pub const RDMA_DRIVER_SIW: u32 = 18u32;
pub const RDMA_DRIVER_UNKNOWN: u32 = 0u32;
pub const RDMA_DRIVER_USNIC: u32 = 13u32;
pub const RDMA_DRIVER_VMW_PVRDMA: u32 = 10u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct _ibv_device_ops {
    pub _dummy1: *mut isize,
    pub _dummy2: *mut isize,
}
impl Default for _ibv_device_ops {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ib_placement_type = u32;
pub type ib_selectivity_level = u32;
pub type ib_uverbs_access_flags = u32;
pub type ib_uverbs_advise_mr_advice = u32;
pub type ib_uverbs_advise_mr_flag = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ah_attr {
    pub grh: ib_uverbs_global_route,
    pub dlid: u16,
    pub sl: u8,
    pub src_path_bits: u8,
    pub static_rate: u8,
    pub is_global: u8,
    pub port_num: u8,
    pub reserved: u8,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_alloc_mw {
    pub response: u64,
    pub pd_handle: u32,
    pub mw_type: u8,
    pub reserved: [u8; 3],
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_alloc_mw {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_alloc_mw_resp {
    pub mw_handle: u32,
    pub rkey: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_alloc_mw_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_alloc_pd {
    pub response: u64,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_alloc_pd {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_alloc_pd_resp {
    pub pd_handle: u32,
    pub driver_data: *mut u32,
}
impl Default for ib_uverbs_alloc_pd_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_async_event_desc {
    pub element: u64,
    pub event_type: u32,
    pub reserved: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_attach_mcast {
    pub gid: [u8; 16],
    pub qp_handle: u32,
    pub mlid: u16,
    pub reserved: u16,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_attach_mcast {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_close_xrcd {
    pub xrcd_handle: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_cmd_hdr {
    pub command: u32,
    pub in_words: u16,
    pub out_words: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_comp_event_desc {
    pub cq_handle: u64,
}
pub type ib_uverbs_core_support = u32;
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_cq_moderation {
    pub cq_count: u16,
    pub cq_period: u16,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_cq_moderation_caps {
    pub max_cq_moderation_count: u16,
    pub max_cq_moderation_period: u16,
    pub reserved: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_create_ah {
    pub response: u64,
    pub user_handle: u64,
    pub pd_handle: u32,
    pub reserved: u32,
    pub attr: ib_uverbs_ah_attr,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_create_ah {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_create_ah_resp {
    pub ah_handle: u32,
    pub driver_data: *mut u32,
}
impl Default for ib_uverbs_create_ah_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_create_comp_channel {
    pub response: u64,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_create_comp_channel_resp {
    pub fd: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_create_cq {
    pub response: u64,
    pub user_handle: u64,
    pub cqe: u32,
    pub comp_vector: u32,
    pub comp_channel: i32,
    pub reserved: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_create_cq {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_create_cq_resp {
    pub cq_handle: u32,
    pub cqe: u32,
    pub driver_data: [u64; 0],
}
impl Default for ib_uverbs_create_cq_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_create_flow {
    pub comp_mask: u32,
    pub qp_handle: u32,
    pub flow_attr: ib_uverbs_flow_attr,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_create_flow_resp {
    pub comp_mask: u32,
    pub flow_handle: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_create_qp {
    pub response: u64,
    pub user_handle: u64,
    pub pd_handle: u32,
    pub send_cq_handle: u32,
    pub recv_cq_handle: u32,
    pub srq_handle: u32,
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
    pub sq_sig_all: u8,
    pub qp_type: u8,
    pub is_srq: u8,
    pub reserved: u8,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_create_qp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ib_uverbs_create_qp_mask = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_create_qp_resp {
    pub qp_handle: u32,
    pub qpn: u32,
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
    pub reserved: u32,
    pub driver_data: [u32; 0],
}
impl Default for ib_uverbs_create_qp_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_create_srq {
    pub response: u64,
    pub user_handle: u64,
    pub pd_handle: u32,
    pub max_wr: u32,
    pub max_sge: u32,
    pub srq_limit: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_create_srq {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_create_srq_resp {
    pub srq_handle: u32,
    pub max_wr: u32,
    pub max_sge: u32,
    pub srqn: u32,
    pub driver_data: *mut u32,
}
impl Default for ib_uverbs_create_srq_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_create_xsrq {
    pub response: u64,
    pub user_handle: u64,
    pub srq_type: u32,
    pub pd_handle: u32,
    pub max_wr: u32,
    pub max_sge: u32,
    pub srq_limit: u32,
    pub max_num_tags: u32,
    pub xrcd_handle: u32,
    pub cq_handle: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_create_xsrq {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_dealloc_mw {
    pub mw_handle: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_dealloc_pd {
    pub pd_handle: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_dereg_mr {
    pub mr_handle: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_destroy_ah {
    pub ah_handle: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_destroy_cq {
    pub response: u64,
    pub cq_handle: u32,
    pub reserved: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_destroy_cq_resp {
    pub comp_events_reported: u32,
    pub async_events_reported: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_destroy_flow {
    pub comp_mask: u32,
    pub flow_handle: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_destroy_qp {
    pub response: u64,
    pub qp_handle: u32,
    pub reserved: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_destroy_qp_resp {
    pub events_reported: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_destroy_srq {
    pub response: u64,
    pub srq_handle: u32,
    pub reserved: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_destroy_srq_resp {
    pub events_reported: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_detach_mcast {
    pub gid: [u8; 16],
    pub qp_handle: u32,
    pub mlid: u16,
    pub reserved: u16,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_detach_mcast {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ib_uverbs_device_cap_flags = u64;
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_cmd_hdr {
    pub response: u64,
    pub provider_in_words: u16,
    pub provider_out_words: u16,
    pub cmd_hdr_reserved: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_create_cq {
    pub user_handle: u64,
    pub cqe: u32,
    pub comp_vector: u32,
    pub comp_channel: i32,
    pub comp_mask: u32,
    pub flags: u32,
    pub reserved: u32,
}
pub type ib_uverbs_ex_create_cq_flags = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_create_cq_resp {
    pub base: ib_uverbs_create_cq_resp,
    pub comp_mask: u32,
    pub response_length: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_create_qp {
    pub user_handle: u64,
    pub pd_handle: u32,
    pub send_cq_handle: u32,
    pub recv_cq_handle: u32,
    pub srq_handle: u32,
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
    pub sq_sig_all: u8,
    pub qp_type: u8,
    pub is_srq: u8,
    pub reserved: u8,
    pub comp_mask: u32,
    pub create_flags: u32,
    pub rwq_ind_tbl_handle: u32,
    pub source_qpn: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_create_qp_resp {
    pub base: ib_uverbs_create_qp_resp,
    pub comp_mask: u32,
    pub response_length: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_ex_create_rwq_ind_table {
    pub comp_mask: u32,
    pub log_ind_tbl_size: u32,
    pub wq_handles: *mut u32,
}
impl Default for ib_uverbs_ex_create_rwq_ind_table {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_create_rwq_ind_table_resp {
    pub comp_mask: u32,
    pub response_length: u32,
    pub ind_tbl_handle: u32,
    pub ind_tbl_num: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_create_wq {
    pub comp_mask: u32,
    pub wq_type: u32,
    pub user_handle: u64,
    pub pd_handle: u32,
    pub cq_handle: u32,
    pub max_wr: u32,
    pub max_sge: u32,
    pub create_flags: u32,
    pub reserved: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_create_wq_resp {
    pub comp_mask: u32,
    pub response_length: u32,
    pub wq_handle: u32,
    pub max_wr: u32,
    pub max_sge: u32,
    pub wqn: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_destroy_rwq_ind_table {
    pub comp_mask: u32,
    pub ind_tbl_handle: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_destroy_wq {
    pub comp_mask: u32,
    pub wq_handle: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_destroy_wq_resp {
    pub comp_mask: u32,
    pub response_length: u32,
    pub events_reported: u32,
    pub reserved: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_modify_cq {
    pub cq_handle: u32,
    pub attr_mask: u32,
    pub attr: ib_uverbs_cq_moderation,
    pub reserved: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_modify_qp {
    pub base: ib_uverbs_modify_qp,
    pub rate_limit: u32,
    pub reserved: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_modify_qp_resp {
    pub comp_mask: u32,
    pub response_length: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_modify_wq {
    pub attr_mask: u32,
    pub wq_handle: u32,
    pub wq_state: u32,
    pub curr_wq_state: u32,
    pub flags: u32,
    pub flags_mask: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_query_device {
    pub comp_mask: u32,
    pub reserved: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_ex_query_device_resp {
    pub base: ib_uverbs_query_device_resp,
    pub comp_mask: u32,
    pub response_length: u32,
    pub odp_caps: ib_uverbs_odp_caps,
    pub timestamp_mask: u64,
    pub hca_core_clock: u64,
    pub device_cap_flags_ex: u64,
    pub rss_caps: ib_uverbs_rss_caps,
    pub max_wq_type_rq: u32,
    pub raw_packet_caps: u32,
    pub tm_caps: ib_uverbs_tm_caps,
    pub cq_moderation_caps: ib_uverbs_cq_moderation_caps,
    pub max_dm_size: u64,
    pub xrc_odp_caps: u32,
    pub reserved: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_action_esp {
    pub spi: u32,
    pub seq: u32,
    pub tfc_pad: u32,
    pub flags: u32,
    pub hard_limit_pkts: u64,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_action_esp_encap {
    pub ib_uverbs_flow_action_esp_encap__anon_0: ib_uverbs_flow_action_esp_encap__anon_0,
    pub ib_uverbs_flow_action_esp_encap__anon_1: ib_uverbs_flow_action_esp_encap__anon_1,
    pub len: u16,
    pub r#type: u16,
    pub _padding: [u8; 4],
}
impl Default for ib_uverbs_flow_action_esp_encap {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_action_esp_encap__anon_0 {
    pub val_ptr: *mut core::ffi::c_void,
    pub val_ptr_data_u64: u64,
}
impl Default for ib_uverbs_flow_action_esp_encap__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_action_esp_encap__anon_1 {
    pub next_ptr: *mut ib_uverbs_flow_action_esp_encap,
    pub next_ptr_data_u64: u64,
}
impl Default for ib_uverbs_flow_action_esp_encap__anon_1 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ib_uverbs_flow_action_esp_flags = u32;
pub type ib_uverbs_flow_action_esp_keymat = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_action_esp_keymat_aes_gcm {
    pub iv: u64,
    pub iv_algo: u32,
    pub salt: u32,
    pub icv_len: u32,
    pub key_len: u32,
    pub aes_key: [u32; 8],
}
impl Default for ib_uverbs_flow_action_esp_keymat_aes_gcm {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ib_uverbs_flow_action_esp_keymat_aes_gcm_iv_algo = u32;
pub type ib_uverbs_flow_action_esp_replay = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_action_esp_replay_bmp {
    pub size: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_attr {
    pub r#type: u32,
    pub size: u16,
    pub priority: u16,
    pub num_of_specs: u8,
    pub reserved: [u8; 2],
    pub port: u8,
    pub flags: u32,
    pub flow_specs: *mut ib_uverbs_flow_spec_hdr,
}
impl Default for ib_uverbs_flow_attr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_eth_filter {
    pub dst_mac: [u8; 6],
    pub src_mac: [u8; 6],
    pub ether_type: bnd_linux::linux::types::__be16,
    pub vlan_tag: bnd_linux::linux::types::__be16,
}
impl Default for ib_uverbs_flow_eth_filter {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_gre_filter {
    pub c_ks_res0_ver: bnd_linux::linux::types::__be16,
    pub protocol: bnd_linux::linux::types::__be16,
    pub key: bnd_linux::linux::types::__be32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_ipv4_filter {
    pub src_ip: bnd_linux::linux::types::__be32,
    pub dst_ip: bnd_linux::linux::types::__be32,
    pub proto: u8,
    pub tos: u8,
    pub ttl: u8,
    pub flags: u8,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_ipv6_filter {
    pub src_ip: [u8; 16],
    pub dst_ip: [u8; 16],
    pub flow_label: bnd_linux::linux::types::__be32,
    pub next_hdr: u8,
    pub traffic_class: u8,
    pub hop_limit: u8,
    pub reserved: u8,
}
impl Default for ib_uverbs_flow_ipv6_filter {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_mpls_filter {
    pub label: bnd_linux::linux::types::__be32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_action_count {
    pub ib_uverbs_flow_spec_action_count__anon_0: ib_uverbs_flow_spec_action_count__anon_0,
    pub handle: u32,
    pub reserved1: u32,
}
impl Default for ib_uverbs_flow_spec_action_count {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_spec_action_count__anon_0 {
    pub hdr: ib_uverbs_flow_spec_hdr,
    pub ib_uverbs_flow_spec_action_count__anon_0__anon_0:
        ib_uverbs_flow_spec_action_count__anon_0__anon_0,
}
impl Default for ib_uverbs_flow_spec_action_count__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_action_count__anon_0__anon_0 {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_action_drop {
    pub ib_uverbs_flow_spec_action_drop__anon_0: ib_uverbs_flow_spec_action_drop__anon_0,
}
impl Default for ib_uverbs_flow_spec_action_drop {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_spec_action_drop__anon_0 {
    pub hdr: ib_uverbs_flow_spec_hdr,
    pub ib_uverbs_flow_spec_action_drop__anon_0__anon_0:
        ib_uverbs_flow_spec_action_drop__anon_0__anon_0,
}
impl Default for ib_uverbs_flow_spec_action_drop__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_action_drop__anon_0__anon_0 {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_action_handle {
    pub ib_uverbs_flow_spec_action_handle__anon_0: ib_uverbs_flow_spec_action_handle__anon_0,
    pub handle: u32,
    pub reserved1: u32,
}
impl Default for ib_uverbs_flow_spec_action_handle {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_spec_action_handle__anon_0 {
    pub hdr: ib_uverbs_flow_spec_hdr,
    pub ib_uverbs_flow_spec_action_handle__anon_0__anon_0:
        ib_uverbs_flow_spec_action_handle__anon_0__anon_0,
}
impl Default for ib_uverbs_flow_spec_action_handle__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_action_handle__anon_0__anon_0 {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_action_tag {
    pub ib_uverbs_flow_spec_action_tag__anon_0: ib_uverbs_flow_spec_action_tag__anon_0,
    pub tag_id: u32,
    pub reserved1: u32,
}
impl Default for ib_uverbs_flow_spec_action_tag {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_spec_action_tag__anon_0 {
    pub hdr: ib_uverbs_flow_spec_hdr,
    pub ib_uverbs_flow_spec_action_tag__anon_0__anon_0:
        ib_uverbs_flow_spec_action_tag__anon_0__anon_0,
}
impl Default for ib_uverbs_flow_spec_action_tag__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_action_tag__anon_0__anon_0 {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_esp {
    pub ib_uverbs_flow_spec_esp__anon_0: ib_uverbs_flow_spec_esp__anon_0,
    pub val: ib_uverbs_flow_spec_esp_filter,
    pub mask: ib_uverbs_flow_spec_esp_filter,
}
impl Default for ib_uverbs_flow_spec_esp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_spec_esp__anon_0 {
    pub hdr: ib_uverbs_flow_spec_hdr,
    pub ib_uverbs_flow_spec_esp__anon_0__anon_0: ib_uverbs_flow_spec_esp__anon_0__anon_0,
}
impl Default for ib_uverbs_flow_spec_esp__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_esp__anon_0__anon_0 {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_esp_filter {
    pub spi: u32,
    pub seq: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_eth {
    pub ib_uverbs_flow_spec_eth__anon_0: ib_uverbs_flow_spec_eth__anon_0,
    pub val: ib_uverbs_flow_eth_filter,
    pub mask: ib_uverbs_flow_eth_filter,
}
impl Default for ib_uverbs_flow_spec_eth {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_spec_eth__anon_0 {
    pub hdr: ib_uverbs_flow_spec_hdr,
    pub ib_uverbs_flow_spec_eth__anon_0__anon_0: ib_uverbs_flow_spec_eth__anon_0__anon_0,
}
impl Default for ib_uverbs_flow_spec_eth__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_eth__anon_0__anon_0 {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_gre {
    pub ib_uverbs_flow_spec_gre__anon_0: ib_uverbs_flow_spec_gre__anon_0,
    pub val: ib_uverbs_flow_gre_filter,
    pub mask: ib_uverbs_flow_gre_filter,
}
impl Default for ib_uverbs_flow_spec_gre {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_spec_gre__anon_0 {
    pub hdr: ib_uverbs_flow_spec_hdr,
    pub ib_uverbs_flow_spec_gre__anon_0__anon_0: ib_uverbs_flow_spec_gre__anon_0__anon_0,
}
impl Default for ib_uverbs_flow_spec_gre__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_gre__anon_0__anon_0 {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_hdr {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
    pub flow_spec_data: [u64; 0],
}
impl Default for ib_uverbs_flow_spec_hdr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_ipv4 {
    pub ib_uverbs_flow_spec_ipv4__anon_0: ib_uverbs_flow_spec_ipv4__anon_0,
    pub val: ib_uverbs_flow_ipv4_filter,
    pub mask: ib_uverbs_flow_ipv4_filter,
}
impl Default for ib_uverbs_flow_spec_ipv4 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_spec_ipv4__anon_0 {
    pub hdr: ib_uverbs_flow_spec_hdr,
    pub ib_uverbs_flow_spec_ipv4__anon_0__anon_0: ib_uverbs_flow_spec_ipv4__anon_0__anon_0,
}
impl Default for ib_uverbs_flow_spec_ipv4__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_ipv4__anon_0__anon_0 {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_ipv6 {
    pub ib_uverbs_flow_spec_ipv6__anon_0: ib_uverbs_flow_spec_ipv6__anon_0,
    pub val: ib_uverbs_flow_ipv6_filter,
    pub mask: ib_uverbs_flow_ipv6_filter,
}
impl Default for ib_uverbs_flow_spec_ipv6 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_spec_ipv6__anon_0 {
    pub hdr: ib_uverbs_flow_spec_hdr,
    pub ib_uverbs_flow_spec_ipv6__anon_0__anon_0: ib_uverbs_flow_spec_ipv6__anon_0__anon_0,
}
impl Default for ib_uverbs_flow_spec_ipv6__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_ipv6__anon_0__anon_0 {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_mpls {
    pub ib_uverbs_flow_spec_mpls__anon_0: ib_uverbs_flow_spec_mpls__anon_0,
    pub val: ib_uverbs_flow_mpls_filter,
    pub mask: ib_uverbs_flow_mpls_filter,
}
impl Default for ib_uverbs_flow_spec_mpls {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_spec_mpls__anon_0 {
    pub hdr: ib_uverbs_flow_spec_hdr,
    pub ib_uverbs_flow_spec_mpls__anon_0__anon_0: ib_uverbs_flow_spec_mpls__anon_0__anon_0,
}
impl Default for ib_uverbs_flow_spec_mpls__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_mpls__anon_0__anon_0 {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_tcp_udp {
    pub ib_uverbs_flow_spec_tcp_udp__anon_0: ib_uverbs_flow_spec_tcp_udp__anon_0,
    pub val: ib_uverbs_flow_tcp_udp_filter,
    pub mask: ib_uverbs_flow_tcp_udp_filter,
}
impl Default for ib_uverbs_flow_spec_tcp_udp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_spec_tcp_udp__anon_0 {
    pub hdr: ib_uverbs_flow_spec_hdr,
    pub ib_uverbs_flow_spec_tcp_udp__anon_0__anon_0: ib_uverbs_flow_spec_tcp_udp__anon_0__anon_0,
}
impl Default for ib_uverbs_flow_spec_tcp_udp__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_tcp_udp__anon_0__anon_0 {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_flow_spec_tunnel {
    pub ib_uverbs_flow_spec_tunnel__anon_0: ib_uverbs_flow_spec_tunnel__anon_0,
    pub val: ib_uverbs_flow_tunnel_filter,
    pub mask: ib_uverbs_flow_tunnel_filter,
}
impl Default for ib_uverbs_flow_spec_tunnel {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_flow_spec_tunnel__anon_0 {
    pub hdr: ib_uverbs_flow_spec_hdr,
    pub ib_uverbs_flow_spec_tunnel__anon_0__anon_0: ib_uverbs_flow_spec_tunnel__anon_0__anon_0,
}
impl Default for ib_uverbs_flow_spec_tunnel__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_spec_tunnel__anon_0__anon_0 {
    pub r#type: u32,
    pub size: u16,
    pub reserved: u16,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_tcp_udp_filter {
    pub dst_port: bnd_linux::linux::types::__be16,
    pub src_port: bnd_linux::linux::types::__be16,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_flow_tunnel_filter {
    pub tunnel_id: bnd_linux::linux::types::__be32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_get_context {
    pub response: u64,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_get_context {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_get_context_resp {
    pub async_fd: u32,
    pub num_comp_vectors: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_get_context_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_gid_entry {
    pub gid: [u64; 2],
    pub gid_index: u32,
    pub port_num: u32,
    pub gid_type: u32,
    pub netdev_ifindex: u32,
}
impl Default for ib_uverbs_gid_entry {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ib_uverbs_gid_type = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_global_route {
    pub dgid: [u8; 16],
    pub flow_label: u32,
    pub sgid_index: u8,
    pub hop_limit: u8,
    pub traffic_class: u8,
    pub reserved: u8,
}
impl Default for ib_uverbs_global_route {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_modify_qp {
    pub dest: ib_uverbs_qp_dest,
    pub alt_dest: ib_uverbs_qp_dest,
    pub qp_handle: u32,
    pub attr_mask: u32,
    pub qkey: u32,
    pub rq_psn: u32,
    pub sq_psn: u32,
    pub dest_qp_num: u32,
    pub qp_access_flags: u32,
    pub pkey_index: u16,
    pub alt_pkey_index: u16,
    pub qp_state: u8,
    pub cur_qp_state: u8,
    pub path_mtu: u8,
    pub path_mig_state: u8,
    pub en_sqd_async_notify: u8,
    pub max_rd_atomic: u8,
    pub max_dest_rd_atomic: u8,
    pub min_rnr_timer: u8,
    pub port_num: u8,
    pub timeout: u8,
    pub retry_cnt: u8,
    pub rnr_retry: u8,
    pub alt_port_num: u8,
    pub alt_timeout: u8,
    pub reserved: [u8; 2],
    pub driver_data: [u64; 0],
}
impl Default for ib_uverbs_modify_qp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_modify_srq {
    pub srq_handle: u32,
    pub attr_mask: u32,
    pub max_wr: u32,
    pub srq_limit: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_modify_srq {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_odp_caps {
    pub general_caps: u64,
    pub per_transport_caps: ib_uverbs_odp_caps_per_transport_caps,
    pub reserved: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_odp_caps_per_transport_caps {
    pub rc_odp_caps: u32,
    pub uc_odp_caps: u32,
    pub ud_odp_caps: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_open_qp {
    pub response: u64,
    pub user_handle: u64,
    pub pd_handle: u32,
    pub qpn: u32,
    pub qp_type: u8,
    pub reserved: [u8; 7],
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_open_qp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_open_xrcd {
    pub response: u64,
    pub fd: u32,
    pub oflags: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_open_xrcd {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_open_xrcd_resp {
    pub xrcd_handle: u32,
    pub driver_data: *mut u32,
}
impl Default for ib_uverbs_open_xrcd_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_poll_cq {
    pub response: u64,
    pub cq_handle: u32,
    pub ne: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_poll_cq_resp {
    pub count: u32,
    pub reserved: u32,
    pub wc: *mut ib_uverbs_wc,
}
impl Default for ib_uverbs_poll_cq_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_post_recv {
    pub response: u64,
    pub qp_handle: u32,
    pub wr_count: u32,
    pub sge_count: u32,
    pub wqe_size: u32,
    pub recv_wr: *mut ib_uverbs_recv_wr,
}
impl Default for ib_uverbs_post_recv {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_post_recv_resp {
    pub bad_wr: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_post_send {
    pub response: u64,
    pub qp_handle: u32,
    pub wr_count: u32,
    pub sge_count: u32,
    pub wqe_size: u32,
    pub send_wr: *mut ib_uverbs_send_wr,
}
impl Default for ib_uverbs_post_send {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_post_send_resp {
    pub bad_wr: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_post_srq_recv {
    pub response: u64,
    pub srq_handle: u32,
    pub wr_count: u32,
    pub sge_count: u32,
    pub wqe_size: u32,
    pub recv: *mut ib_uverbs_recv_wr,
}
impl Default for ib_uverbs_post_srq_recv {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_post_srq_recv_resp {
    pub bad_wr: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_qp_attr {
    pub qp_attr_mask: u32,
    pub qp_state: u32,
    pub cur_qp_state: u32,
    pub path_mtu: u32,
    pub path_mig_state: u32,
    pub qkey: u32,
    pub rq_psn: u32,
    pub sq_psn: u32,
    pub dest_qp_num: u32,
    pub qp_access_flags: u32,
    pub ah_attr: ib_uverbs_ah_attr,
    pub alt_ah_attr: ib_uverbs_ah_attr,
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
    pub pkey_index: u16,
    pub alt_pkey_index: u16,
    pub en_sqd_async_notify: u8,
    pub sq_draining: u8,
    pub max_rd_atomic: u8,
    pub max_dest_rd_atomic: u8,
    pub min_rnr_timer: u8,
    pub port_num: u8,
    pub timeout: u8,
    pub retry_cnt: u8,
    pub rnr_retry: u8,
    pub alt_port_num: u8,
    pub alt_timeout: u8,
    pub reserved: [u8; 5],
}
impl Default for ib_uverbs_qp_attr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_qp_cap {
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
}
pub type ib_uverbs_qp_create_flags = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_qp_dest {
    pub dgid: [u8; 16],
    pub flow_label: u32,
    pub dlid: u16,
    pub reserved: u16,
    pub sgid_index: u8,
    pub hop_limit: u8,
    pub traffic_class: u8,
    pub sl: u8,
    pub src_path_bits: u8,
    pub static_rate: u8,
    pub is_global: u8,
    pub port_num: u8,
}
impl Default for ib_uverbs_qp_dest {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ib_uverbs_qp_type = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_query_device {
    pub response: u64,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_query_device {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_query_device_resp {
    pub fw_ver: u64,
    pub node_guid: bnd_linux::linux::types::__be64,
    pub sys_image_guid: bnd_linux::linux::types::__be64,
    pub max_mr_size: u64,
    pub page_size_cap: u64,
    pub vendor_id: u32,
    pub vendor_part_id: u32,
    pub hw_ver: u32,
    pub max_qp: u32,
    pub max_qp_wr: u32,
    pub device_cap_flags: u32,
    pub max_sge: u32,
    pub max_sge_rd: u32,
    pub max_cq: u32,
    pub max_cqe: u32,
    pub max_mr: u32,
    pub max_pd: u32,
    pub max_qp_rd_atom: u32,
    pub max_ee_rd_atom: u32,
    pub max_res_rd_atom: u32,
    pub max_qp_init_rd_atom: u32,
    pub max_ee_init_rd_atom: u32,
    pub atomic_cap: u32,
    pub max_ee: u32,
    pub max_rdd: u32,
    pub max_mw: u32,
    pub max_raw_ipv6_qp: u32,
    pub max_raw_ethy_qp: u32,
    pub max_mcast_grp: u32,
    pub max_mcast_qp_attach: u32,
    pub max_total_mcast_qp_attach: u32,
    pub max_ah: u32,
    pub max_fmr: u32,
    pub max_map_per_fmr: u32,
    pub max_srq: u32,
    pub max_srq_wr: u32,
    pub max_srq_sge: u32,
    pub max_pkeys: u16,
    pub local_ca_ack_delay: u8,
    pub phys_port_cnt: u8,
    pub reserved: [u8; 4],
}
impl Default for ib_uverbs_query_device_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_query_port {
    pub response: u64,
    pub port_num: u8,
    pub reserved: [u8; 7],
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_query_port {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ib_uverbs_query_port_cap_flags = u32;
pub type ib_uverbs_query_port_flags = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_query_port_resp {
    pub port_cap_flags: u32,
    pub max_msg_sz: u32,
    pub bad_pkey_cntr: u32,
    pub qkey_viol_cntr: u32,
    pub gid_tbl_len: u32,
    pub pkey_tbl_len: u16,
    pub lid: u16,
    pub sm_lid: u16,
    pub state: u8,
    pub max_mtu: u8,
    pub active_mtu: u8,
    pub lmc: u8,
    pub max_vl_num: u8,
    pub sm_sl: u8,
    pub subnet_timeout: u8,
    pub init_type_reply: u8,
    pub active_width: u8,
    pub active_speed: u8,
    pub phys_state: u8,
    pub link_layer: u8,
    pub flags: u8,
    pub reserved: u8,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_query_port_resp_ex {
    pub legacy_resp: ib_uverbs_query_port_resp,
    pub port_cap_flags2: u16,
    pub reserved: [u8; 2],
    pub active_speed_ex: u32,
}
impl Default for ib_uverbs_query_port_resp_ex {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_query_qp {
    pub response: u64,
    pub qp_handle: u32,
    pub attr_mask: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_query_qp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_query_qp_resp {
    pub dest: ib_uverbs_qp_dest,
    pub alt_dest: ib_uverbs_qp_dest,
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
    pub qkey: u32,
    pub rq_psn: u32,
    pub sq_psn: u32,
    pub dest_qp_num: u32,
    pub qp_access_flags: u32,
    pub pkey_index: u16,
    pub alt_pkey_index: u16,
    pub qp_state: u8,
    pub cur_qp_state: u8,
    pub path_mtu: u8,
    pub path_mig_state: u8,
    pub sq_draining: u8,
    pub max_rd_atomic: u8,
    pub max_dest_rd_atomic: u8,
    pub min_rnr_timer: u8,
    pub port_num: u8,
    pub timeout: u8,
    pub retry_cnt: u8,
    pub rnr_retry: u8,
    pub alt_port_num: u8,
    pub alt_timeout: u8,
    pub sq_sig_all: u8,
    pub reserved: [u8; 5],
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_query_qp_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_query_srq {
    pub response: u64,
    pub srq_handle: u32,
    pub reserved: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_query_srq {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_query_srq_resp {
    pub max_wr: u32,
    pub max_sge: u32,
    pub srq_limit: u32,
    pub reserved: u32,
}
pub type ib_uverbs_raw_packet_caps = u32;
pub type ib_uverbs_read_counters_flags = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_recv_wr {
    pub wr_id: u64,
    pub num_sge: u32,
    pub reserved: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_reg_mr {
    pub response: u64,
    pub start: u64,
    pub length: u64,
    pub hca_va: u64,
    pub pd_handle: u32,
    pub access_flags: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_reg_mr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_reg_mr_resp {
    pub mr_handle: u32,
    pub lkey: u32,
    pub rkey: u32,
    pub driver_data: *mut u32,
}
impl Default for ib_uverbs_reg_mr_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_req_notify_cq {
    pub cq_handle: u32,
    pub solicited_only: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_rereg_mr {
    pub response: u64,
    pub mr_handle: u32,
    pub flags: u32,
    pub start: u64,
    pub length: u64,
    pub hca_va: u64,
    pub pd_handle: u32,
    pub access_flags: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_rereg_mr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_rereg_mr_resp {
    pub lkey: u32,
    pub rkey: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_rereg_mr_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_resize_cq {
    pub response: u64,
    pub cq_handle: u32,
    pub cqe: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_resize_cq {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_resize_cq_resp {
    pub cqe: u32,
    pub reserved: u32,
    pub driver_data: *mut u64,
}
impl Default for ib_uverbs_resize_cq_resp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_rss_caps {
    pub supported_qpts: u32,
    pub max_rwq_indirection_tables: u32,
    pub max_rwq_indirection_table_size: u32,
    pub reserved: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_send_wr {
    pub wr_id: u64,
    pub num_sge: u32,
    pub opcode: u32,
    pub send_flags: u32,
    pub ex: ib_uverbs_send_wr_ex,
    pub wr: ib_uverbs_send_wr_wr,
}
impl Default for ib_uverbs_send_wr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub union ib_uverbs_send_wr_ex {
    pub imm_data: bnd_linux::linux::types::__be32,
    pub invalidate_rkey: u32,
}
impl Default for ib_uverbs_send_wr_ex {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ib_uverbs_send_wr_wr {
    pub rdma: ib_uverbs_send_wr_wr_rdma,
    pub atomic: ib_uverbs_send_wr_wr_atomic,
    pub ud: ib_uverbs_send_wr_wr_ud,
}
impl Default for ib_uverbs_send_wr_wr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_send_wr_wr_atomic {
    pub remote_addr: u64,
    pub compare_add: u64,
    pub swap: u64,
    pub rkey: u32,
    pub reserved: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_send_wr_wr_rdma {
    pub remote_addr: u64,
    pub rkey: u32,
    pub reserved: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_send_wr_wr_ud {
    pub ah: u32,
    pub remote_qpn: u32,
    pub remote_qkey: u32,
    pub reserved: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_sge {
    pub addr: u64,
    pub length: u32,
    pub lkey: u32,
}
pub type ib_uverbs_srq_type = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ib_uverbs_tm_caps {
    pub max_rndv_hdr_size: u32,
    pub max_num_tags: u32,
    pub flags: u32,
    pub max_ops: u32,
    pub max_sge: u32,
    pub reserved: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ib_uverbs_wc {
    pub wr_id: u64,
    pub status: u32,
    pub opcode: u32,
    pub vendor_err: u32,
    pub byte_len: u32,
    pub ex: ib_uverbs_wc_ex,
    pub qp_num: u32,
    pub src_qp: u32,
    pub wc_flags: u32,
    pub pkey_index: u16,
    pub slid: u16,
    pub sl: u8,
    pub dlid_path_bits: u8,
    pub port_num: u8,
    pub reserved: u8,
}
impl Default for ib_uverbs_wc {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub union ib_uverbs_wc_ex {
    pub imm_data: bnd_linux::linux::types::__be32,
    pub invalidate_rkey: u32,
}
impl Default for ib_uverbs_wc_ex {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ib_uverbs_wc_opcode = u32;
pub type ib_uverbs_wq_flags = u32;
pub type ib_uverbs_wq_type = u32;
pub type ib_uverbs_wr_opcode = u32;
pub type ib_uverbs_write_cmds = u32;
pub type ibv_access_flags = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_ah {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub handle: u32,
}
impl Default for ibv_ah {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_ah_attr {
    pub grh: ibv_global_route,
    pub dlid: u16,
    pub sl: u8,
    pub src_path_bits: u8,
    pub static_rate: u8,
    pub is_global: u8,
    pub port_num: u8,
}
impl Default for ibv_ah_attr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ibv_alloc_dm_attr {
    pub length: u64,
    pub log_align_req: u32,
    pub comp_mask: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_async_event {
    pub element: ibv_async_event_element,
    pub event_type: ibv_event_type,
}
impl Default for ibv_async_event {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ibv_async_event_element {
    pub cq: *mut ibv_cq,
    pub qp: *mut ibv_qp,
    pub srq: *mut ibv_srq,
    pub wq: *mut ibv_wq,
    pub port_num: i32,
}
impl Default for ibv_async_event_element {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_atomic_cap = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_comp_channel {
    pub context: *mut ibv_context,
    pub fd: i32,
    pub refcnt: i32,
}
impl Default for ibv_comp_channel {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_context {
    pub device: *mut ibv_device,
    pub ops: ibv_context_ops,
    pub cmd_fd: i32,
    pub async_fd: i32,
    pub num_comp_vectors: i32,
    pub mutex: bnd_posix::posix::pthread::pthread_mutex_t,
    pub abi_compat: *mut core::ffi::c_void,
}
impl Default for ibv_context {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_context_ops {
    pub _compat_query_device: *mut isize,
    pub _compat_query_port: *mut isize,
    pub _compat_alloc_pd: *mut isize,
    pub _compat_dealloc_pd: *mut isize,
    pub _compat_reg_mr: *mut isize,
    pub _compat_rereg_mr: *mut isize,
    pub _compat_dereg_mr: *mut isize,
    pub alloc_mw: *mut isize,
    pub bind_mw: *mut isize,
    pub dealloc_mw: *mut isize,
    pub _compat_create_cq: *mut isize,
    pub poll_cq: *mut isize,
    pub req_notify_cq: *mut isize,
    pub _compat_cq_event: *mut isize,
    pub _compat_resize_cq: *mut isize,
    pub _compat_destroy_cq: *mut isize,
    pub _compat_create_srq: *mut isize,
    pub _compat_modify_srq: *mut isize,
    pub _compat_query_srq: *mut isize,
    pub _compat_destroy_srq: *mut isize,
    pub post_srq_recv: *mut isize,
    pub _compat_create_qp: *mut isize,
    pub _compat_query_qp: *mut isize,
    pub _compat_modify_qp: *mut isize,
    pub _compat_destroy_qp: *mut isize,
    pub post_send: *mut isize,
    pub post_recv: *mut isize,
    pub _compat_create_ah: *mut isize,
    pub _compat_destroy_ah: *mut isize,
    pub _compat_attach_mcast: *mut isize,
    pub _compat_detach_mcast: *mut isize,
    pub _compat_async_event: *mut isize,
}
impl Default for ibv_context_ops {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_counter_attach_attr {
    pub counter_desc: ibv_counter_description,
    pub index: u32,
    pub comp_mask: u32,
}
pub type ibv_counter_description = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_counters {
    pub context: *mut ibv_context,
}
impl Default for ibv_counters {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_counters_init_attr {
    pub comp_mask: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_cq {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut core::ffi::c_void,
    pub handle: u32,
    pub cqe: i32,
    pub mutex: bnd_posix::posix::pthread::pthread_mutex_t,
    pub cond: bnd_posix::posix::pthread::pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
}
impl Default for ibv_cq {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_cq_attr_mask = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_cq_ex {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut core::ffi::c_void,
    pub handle: u32,
    pub cqe: i32,
    pub mutex: bnd_posix::posix::pthread::pthread_mutex_t,
    pub cond: bnd_posix::posix::pthread::pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
    pub comp_mask: u32,
    pub status: ibv_wc_status,
    pub wr_id: u64,
    pub start_poll: *mut isize,
    pub next_poll: *mut isize,
    pub end_poll: *mut isize,
    pub read_opcode: *mut isize,
    pub read_vendor_err: *mut isize,
    pub read_byte_len: *mut isize,
    pub read_imm_data: *mut isize,
    pub read_qp_num: *mut isize,
    pub read_src_qp: *mut isize,
    pub read_wc_flags: *mut isize,
    pub read_slid: *mut isize,
    pub read_sl: *mut isize,
    pub read_dlid_path_bits: *mut isize,
    pub read_completion_ts: *mut isize,
    pub read_cvlan: *mut isize,
    pub read_flow_tag: *mut isize,
    pub read_tm_info: *mut isize,
    pub read_completion_wallclock_ns: *mut isize,
}
impl Default for ibv_cq_ex {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_cq_init_attr_ex {
    pub cqe: u32,
    pub cq_context: *mut core::ffi::c_void,
    pub channel: *mut ibv_comp_channel,
    pub comp_vector: u32,
    pub wc_flags: u64,
    pub comp_mask: u32,
    pub flags: u32,
    pub parent_domain: *mut ibv_pd,
}
impl Default for ibv_cq_init_attr_ex {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_cq_init_attr_mask = u32;
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct ibv_cq_moderation_caps {
    pub max_cq_count: u16,
    pub max_cq_period: u16,
}
pub type ibv_create_cq_attr_flags = u32;
pub type ibv_create_cq_wc_flags = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_data_buf {
    pub addr: *mut core::ffi::c_void,
    pub length: u64,
}
impl Default for ibv_data_buf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_device {
    pub _ops: _ibv_device_ops,
    pub node_type: ibv_node_type,
    pub transport_type: ibv_transport_type,
    pub name: [i8; 64],
    pub dev_name: [i8; 64],
    pub dev_path: [i8; 256],
    pub ibdev_path: [i8; 256],
}
impl Default for ibv_device {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_device_attr {
    pub fw_ver: [i8; 64],
    pub node_guid: bnd_linux::linux::types::__be64,
    pub sys_image_guid: bnd_linux::linux::types::__be64,
    pub max_mr_size: u64,
    pub page_size_cap: u64,
    pub vendor_id: u32,
    pub vendor_part_id: u32,
    pub hw_ver: u32,
    pub max_qp: i32,
    pub max_qp_wr: i32,
    pub device_cap_flags: u32,
    pub max_sge: i32,
    pub max_sge_rd: i32,
    pub max_cq: i32,
    pub max_cqe: i32,
    pub max_mr: i32,
    pub max_pd: i32,
    pub max_qp_rd_atom: i32,
    pub max_ee_rd_atom: i32,
    pub max_res_rd_atom: i32,
    pub max_qp_init_rd_atom: i32,
    pub max_ee_init_rd_atom: i32,
    pub atomic_cap: ibv_atomic_cap,
    pub max_ee: i32,
    pub max_rdd: i32,
    pub max_mw: i32,
    pub max_raw_ipv6_qp: i32,
    pub max_raw_ethy_qp: i32,
    pub max_mcast_grp: i32,
    pub max_mcast_qp_attach: i32,
    pub max_total_mcast_qp_attach: i32,
    pub max_ah: i32,
    pub max_fmr: i32,
    pub max_map_per_fmr: i32,
    pub max_srq: i32,
    pub max_srq_wr: i32,
    pub max_srq_sge: i32,
    pub max_pkeys: u16,
    pub local_ca_ack_delay: u8,
    pub phys_port_cnt: u8,
}
impl Default for ibv_device_attr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ibv_device_attr_ex {
    pub orig_attr: ibv_device_attr,
    pub comp_mask: u32,
    pub odp_caps: ibv_odp_caps,
    pub completion_timestamp_mask: u64,
    pub hca_core_clock: u64,
    pub device_cap_flags_ex: u64,
    pub tso_caps: ibv_tso_caps,
    pub rss_caps: ibv_rss_caps,
    pub max_wq_type_rq: u32,
    pub packet_pacing_caps: ibv_packet_pacing_caps,
    pub raw_packet_caps: u32,
    pub tm_caps: ibv_tm_caps,
    pub cq_mod_caps: ibv_cq_moderation_caps,
    pub max_dm_size: u64,
    pub pci_atomic_caps: ibv_pci_atomic_caps,
    pub xrc_odp_caps: u32,
    pub phys_port_cnt_ex: u32,
}
pub type ibv_device_cap_flags = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_dm {
    pub context: *mut ibv_context,
    pub memcpy_to_dm: *mut isize,
    pub memcpy_from_dm: *mut isize,
    pub comp_mask: u32,
    pub handle: u32,
}
impl Default for ibv_dm {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_dm_mask = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_ece {
    pub vendor_id: u32,
    pub options: u32,
    pub comp_mask: u32,
}
pub type ibv_event_type = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_flow {
    pub comp_mask: u32,
    pub context: *mut ibv_context,
    pub handle: u32,
}
impl Default for ibv_flow {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_flow_action {
    pub context: *mut ibv_context,
}
impl Default for ibv_flow_action {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_flow_action_esp_attr {
    pub esp_attr: *mut ib_uverbs_flow_action_esp,
    pub keymat_proto: ib_uverbs_flow_action_esp_keymat,
    pub keymat_len: u16,
    pub keymat_ptr: *mut core::ffi::c_void,
    pub replay_proto: ib_uverbs_flow_action_esp_replay,
    pub replay_len: u16,
    pub replay_ptr: *mut core::ffi::c_void,
    pub esp_encap: *mut ib_uverbs_flow_action_esp_encap,
    pub comp_mask: u32,
    pub esn: u32,
}
impl Default for ibv_flow_action_esp_attr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_flow_action_esp_mask = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_attr {
    pub comp_mask: u32,
    pub r#type: ibv_flow_attr_type,
    pub size: u16,
    pub priority: u16,
    pub num_of_specs: u8,
    pub port: u8,
    pub flags: u32,
}
pub type ibv_flow_attr_type = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_esp_filter {
    pub spi: u32,
    pub seq: u32,
}
#[repr(C, packed(2))]
#[derive(Clone, Copy)]
pub struct ibv_flow_eth_filter {
    pub dst_mac: [u8; 6],
    pub src_mac: [u8; 6],
    pub ether_type: u16,
    pub vlan_tag: u16,
}
impl Default for ibv_flow_eth_filter {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_flow_flags = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_gre_filter {
    pub c_ks_res0_ver: u16,
    pub protocol: u16,
    pub key: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_ipv4_ext_filter {
    pub src_ip: u32,
    pub dst_ip: u32,
    pub proto: u8,
    pub tos: u8,
    pub ttl: u8,
    pub flags: u8,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_ipv4_filter {
    pub src_ip: u32,
    pub dst_ip: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct ibv_flow_ipv6_filter {
    pub src_ip: [u8; 16],
    pub dst_ip: [u8; 16],
    pub flow_label: u32,
    pub next_hdr: u8,
    pub traffic_class: u8,
    pub hop_limit: u8,
}
impl Default for ibv_flow_ipv6_filter {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_mpls_filter {
    pub label: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_flow_spec {
    pub ibv_flow_spec__anon_0: ibv_flow_spec__anon_0,
}
impl Default for ibv_flow_spec {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ibv_flow_spec__anon_0 {
    pub hdr: ibv_flow_spec__anon_0_hdr,
    pub eth: ibv_flow_spec_eth,
    pub ipv4: ibv_flow_spec_ipv4,
    pub tcp_udp: ibv_flow_spec_tcp_udp,
    pub ipv4_ext: ibv_flow_spec_ipv4_ext,
    pub ipv6: ibv_flow_spec_ipv6,
    pub esp: ibv_flow_spec_esp,
    pub tunnel: ibv_flow_spec_tunnel,
    pub gre: ibv_flow_spec_gre,
    pub mpls: ibv_flow_spec_mpls,
    pub flow_tag: ibv_flow_spec_action_tag,
    pub drop: ibv_flow_spec_action_drop,
    pub handle: ibv_flow_spec_action_handle,
    pub flow_count: ibv_flow_spec_counter_action,
}
impl Default for ibv_flow_spec__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_spec__anon_0_hdr {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_spec_action_drop {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_flow_spec_action_handle {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
    pub action: *mut ibv_flow_action,
}
impl Default for ibv_flow_spec_action_handle {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_spec_action_tag {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
    pub tag_id: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_flow_spec_counter_action {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
    pub counters: *mut ibv_counters,
}
impl Default for ibv_flow_spec_counter_action {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_spec_esp {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_esp_filter,
    pub mask: ibv_flow_esp_filter,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_spec_eth {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_eth_filter,
    pub mask: ibv_flow_eth_filter,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_spec_gre {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_gre_filter,
    pub mask: ibv_flow_gre_filter,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_spec_ipv4 {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_ipv4_filter,
    pub mask: ibv_flow_ipv4_filter,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_spec_ipv4_ext {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_ipv4_ext_filter,
    pub mask: ibv_flow_ipv4_ext_filter,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_spec_ipv6 {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_ipv6_filter,
    pub mask: ibv_flow_ipv6_filter,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_spec_mpls {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_mpls_filter,
    pub mask: ibv_flow_mpls_filter,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_spec_tcp_udp {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_tcp_udp_filter,
    pub mask: ibv_flow_tcp_udp_filter,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_spec_tunnel {
    pub r#type: ibv_flow_spec_type,
    pub size: u16,
    pub val: ibv_flow_tunnel_filter,
    pub mask: ibv_flow_tunnel_filter,
}
pub type ibv_flow_spec_type = u32;
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_tcp_udp_filter {
    pub dst_port: u16,
    pub src_port: u16,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_flow_tunnel_filter {
    pub tunnel_id: u32,
}
pub type ibv_fork_status = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ibv_gid {
    pub raw: [u8; 16],
    pub global: ibv_gid_global,
}
impl Default for ibv_gid {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_gid_entry {
    pub gid: ibv_gid,
    pub gid_index: u32,
    pub port_num: u32,
    pub gid_type: u32,
    pub ndev_ifindex: u32,
}
impl Default for ibv_gid_entry {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ibv_gid_global {
    pub subnet_prefix: bnd_linux::linux::types::__be64,
    pub interface_id: bnd_linux::linux::types::__be64,
}
pub type ibv_gid_type = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_global_route {
    pub dgid: ibv_gid,
    pub flow_label: u32,
    pub sgid_index: u8,
    pub hop_limit: u8,
    pub traffic_class: u8,
}
impl Default for ibv_global_route {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_grh {
    pub version_tclass_flow: bnd_linux::linux::types::__be32,
    pub paylen: bnd_linux::linux::types::__be16,
    pub next_hdr: u8,
    pub hop_limit: u8,
    pub sgid: ibv_gid,
    pub dgid: ibv_gid,
}
impl Default for ibv_grh {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_ind_table_init_attr_mask = u32;
pub type ibv_mig_state = u32;
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct ibv_moderate_cq {
    pub cq_count: u16,
    pub cq_period: u16,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_modify_cq_attr {
    pub attr_mask: u32,
    pub moderate: ibv_moderate_cq,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_mr {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub addr: *mut core::ffi::c_void,
    pub length: u64,
    pub handle: u32,
    pub lkey: u32,
    pub rkey: u32,
}
impl Default for ibv_mr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_mtu = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_mw {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub rkey: u32,
    pub handle: u32,
    pub r#type: ibv_mw_type,
}
impl Default for ibv_mw {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ibv_mw_bind {
    pub wr_id: u64,
    pub send_flags: u32,
    pub bind_info: ibv_mw_bind_info,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_mw_bind_info {
    pub mr: *mut ibv_mr,
    pub addr: u64,
    pub length: u64,
    pub mw_access_flags: u32,
}
impl Default for ibv_mw_bind_info {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_mw_type = u32;
pub type ibv_node_type = i32;
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ibv_odp_caps {
    pub general_caps: u64,
    pub per_transport_caps: ibv_odp_caps_per_transport_caps,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_odp_caps_per_transport_caps {
    pub rc_odp_caps: u32,
    pub uc_odp_caps: u32,
    pub ud_odp_caps: u32,
}
pub type ibv_odp_general_caps = u32;
pub type ibv_odp_transport_cap_bits = u32;
pub type ibv_ops_flags = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_ops_wr {
    pub wr_id: u64,
    pub next: *mut ibv_ops_wr,
    pub opcode: ibv_ops_wr_opcode,
    pub flags: i32,
    pub tm: ibv_ops_wr_tm,
}
impl Default for ibv_ops_wr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_ops_wr_opcode = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ibv_ops_wr_tm {
    pub unexpected_cnt: u32,
    pub handle: u32,
    pub add: ibv_ops_wr_tm_add,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_ops_wr_tm_add {
    pub recv_wr_id: u64,
    pub sg_list: *mut ibv_sge,
    pub num_sge: i32,
    pub tag: u64,
    pub mask: u64,
}
impl Default for ibv_ops_wr_tm_add {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_packet_pacing_caps {
    pub qp_rate_limit_min: u32,
    pub qp_rate_limit_max: u32,
    pub supported_qpts: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_parent_domain_init_attr {
    pub pd: *mut ibv_pd,
    pub td: *mut ibv_td,
    pub comp_mask: u32,
    pub alloc: *mut isize,
    pub free: *mut isize,
    pub pd_context: *mut core::ffi::c_void,
}
impl Default for ibv_parent_domain_init_attr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_parent_domain_init_attr_mask = u32;
#[repr(C, packed(2))]
#[derive(Clone, Copy, Default)]
pub struct ibv_pci_atomic_caps {
    pub fetch_add: u16,
    pub swap: u16,
    pub compare_swap: u16,
}
pub type ibv_pci_atomic_op_size = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_pd {
    pub context: *mut ibv_context,
    pub handle: u32,
}
impl Default for ibv_pd {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_placement_type = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_poll_cq_attr {
    pub comp_mask: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_port_attr {
    pub state: ibv_port_state,
    pub max_mtu: ibv_mtu,
    pub active_mtu: ibv_mtu,
    pub gid_tbl_len: i32,
    pub port_cap_flags: u32,
    pub max_msg_sz: u32,
    pub bad_pkey_cntr: u32,
    pub qkey_viol_cntr: u32,
    pub pkey_tbl_len: u16,
    pub lid: u16,
    pub sm_lid: u16,
    pub lmc: u8,
    pub max_vl_num: u8,
    pub sm_sl: u8,
    pub subnet_timeout: u8,
    pub init_type_reply: u8,
    pub active_width: u8,
    pub active_speed: u8,
    pub phys_state: u8,
    pub link_layer: u8,
    pub flags: u8,
    pub port_cap_flags2: u16,
    pub active_speed_ex: u32,
}
pub type ibv_port_cap_flags = u32;
pub type ibv_port_cap_flags2 = u32;
pub type ibv_port_state = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_qp {
    pub context: *mut ibv_context,
    pub qp_context: *mut core::ffi::c_void,
    pub pd: *mut ibv_pd,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub handle: u32,
    pub qp_num: u32,
    pub state: ibv_qp_state,
    pub qp_type: ibv_qp_type,
    pub mutex: bnd_posix::posix::pthread::pthread_mutex_t,
    pub cond: bnd_posix::posix::pthread::pthread_cond_t,
    pub events_completed: u32,
}
impl Default for ibv_qp {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_qp_attr {
    pub qp_state: ibv_qp_state,
    pub cur_qp_state: ibv_qp_state,
    pub path_mtu: ibv_mtu,
    pub path_mig_state: ibv_mig_state,
    pub qkey: u32,
    pub rq_psn: u32,
    pub sq_psn: u32,
    pub dest_qp_num: u32,
    pub qp_access_flags: u32,
    pub cap: ibv_qp_cap,
    pub ah_attr: ibv_ah_attr,
    pub alt_ah_attr: ibv_ah_attr,
    pub pkey_index: u16,
    pub alt_pkey_index: u16,
    pub en_sqd_async_notify: u8,
    pub sq_draining: u8,
    pub max_rd_atomic: u8,
    pub max_dest_rd_atomic: u8,
    pub min_rnr_timer: u8,
    pub port_num: u8,
    pub timeout: u8,
    pub retry_cnt: u8,
    pub rnr_retry: u8,
    pub alt_port_num: u8,
    pub alt_timeout: u8,
    pub rate_limit: u32,
}
impl Default for ibv_qp_attr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_qp_attr_mask = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_qp_cap {
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
}
pub type ibv_qp_create_flags = u32;
pub type ibv_qp_create_send_ops_flags = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_qp_ex {
    pub qp_base: ibv_qp,
    pub comp_mask: u64,
    pub wr_id: u64,
    pub wr_flags: u32,
    pub wr_atomic_cmp_swp: *mut isize,
    pub wr_atomic_fetch_add: *mut isize,
    pub wr_bind_mw: *mut isize,
    pub wr_local_inv: *mut isize,
    pub wr_rdma_read: *mut isize,
    pub wr_rdma_write: *mut isize,
    pub wr_rdma_write_imm: *mut isize,
    pub wr_send: *mut isize,
    pub wr_send_imm: *mut isize,
    pub wr_send_inv: *mut isize,
    pub wr_send_tso: *mut isize,
    pub wr_set_ud_addr: *mut isize,
    pub wr_set_xrc_srqn: *mut isize,
    pub wr_set_inline_data: *mut isize,
    pub wr_set_inline_data_list: *mut isize,
    pub wr_set_sge: *mut isize,
    pub wr_set_sge_list: *mut isize,
    pub wr_start: *mut isize,
    pub wr_complete: *mut isize,
    pub wr_abort: *mut isize,
    pub wr_atomic_write: *mut isize,
    pub wr_flush: *mut isize,
}
impl Default for ibv_qp_ex {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_qp_init_attr {
    pub qp_context: *mut core::ffi::c_void,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub cap: ibv_qp_cap,
    pub qp_type: ibv_qp_type,
    pub sq_sig_all: i32,
}
impl Default for ibv_qp_init_attr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_qp_init_attr_ex {
    pub qp_context: *mut core::ffi::c_void,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub cap: ibv_qp_cap,
    pub qp_type: ibv_qp_type,
    pub sq_sig_all: i32,
    pub comp_mask: u32,
    pub pd: *mut ibv_pd,
    pub xrcd: *mut ibv_xrcd,
    pub create_flags: u32,
    pub max_tso_header: u16,
    pub rwq_ind_tbl: *mut ibv_rwq_ind_table,
    pub rx_hash_conf: ibv_rx_hash_conf,
    pub source_qpn: u32,
    pub send_ops_flags: u64,
}
impl Default for ibv_qp_init_attr_ex {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_qp_init_attr_mask = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_qp_open_attr {
    pub comp_mask: u32,
    pub qp_num: u32,
    pub xrcd: *mut ibv_xrcd,
    pub qp_context: *mut core::ffi::c_void,
    pub qp_type: ibv_qp_type,
}
impl Default for ibv_qp_open_attr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_qp_open_attr_mask = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_qp_rate_limit_attr {
    pub rate_limit: u32,
    pub max_burst_sz: u32,
    pub typical_pkt_sz: u16,
    pub comp_mask: u32,
}
pub type ibv_qp_state = u32;
pub type ibv_qp_type = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_query_device_ex_input {
    pub comp_mask: u32,
}
pub type ibv_query_qp_data_in_order_caps = u32;
pub type ibv_query_qp_data_in_order_flags = u32;
pub type ibv_rate = u32;
pub type ibv_raw_packet_caps = u32;
pub type ibv_read_counters_flags = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_recv_wr {
    pub wr_id: u64,
    pub next: *mut ibv_recv_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: i32,
}
impl Default for ibv_recv_wr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_rereg_mr_err_code = i32;
pub type ibv_rereg_mr_flags = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ibv_rss_caps {
    pub supported_qpts: u32,
    pub max_rwq_indirection_tables: u32,
    pub max_rwq_indirection_table_size: u32,
    pub rx_hash_fields_mask: u64,
    pub rx_hash_function: u8,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_rwq_ind_table {
    pub context: *mut ibv_context,
    pub ind_tbl_handle: i32,
    pub ind_tbl_num: i32,
    pub comp_mask: u32,
}
impl Default for ibv_rwq_ind_table {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_rwq_ind_table_init_attr {
    pub log_ind_tbl_size: u32,
    pub ind_tbl: *mut *mut ibv_wq,
    pub comp_mask: u32,
}
impl Default for ibv_rwq_ind_table_init_attr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_rx_hash_conf {
    pub rx_hash_function: u8,
    pub rx_hash_key_len: u8,
    pub rx_hash_key: *mut u8,
    pub rx_hash_fields_mask: u64,
}
impl Default for ibv_rx_hash_conf {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_rx_hash_fields = u32;
pub type ibv_rx_hash_function_flags = u32;
pub type ibv_selectivity_level = u32;
pub type ibv_send_flags = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_send_wr {
    pub wr_id: u64,
    pub next: *mut ibv_send_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: i32,
    pub opcode: ibv_wr_opcode,
    pub send_flags: u32,
    pub ibv_send_wr__anon_0: ibv_send_wr__anon_0,
    pub wr: ibv_send_wr_wr,
    pub qp_type: ibv_send_wr_qp_type,
    pub ibv_send_wr__anon_1: ibv_send_wr__anon_1,
    pub _padding: [u8; 52],
}
impl Default for ibv_send_wr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub union ibv_send_wr__anon_0 {
    pub imm_data: bnd_linux::linux::types::__be32,
    pub invalidate_rkey: u32,
}
impl Default for ibv_send_wr__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ibv_send_wr__anon_1 {
    pub bind_mw: ibv_send_wr__anon_1_bind_mw,
    pub tso: ibv_send_wr__anon_1_tso,
}
impl Default for ibv_send_wr__anon_1 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_send_wr__anon_1_bind_mw {
    pub mw: *mut ibv_mw,
    pub rkey: u32,
    pub bind_info: ibv_mw_bind_info,
}
impl Default for ibv_send_wr__anon_1_bind_mw {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_send_wr__anon_1_tso {
    pub hdr: *mut core::ffi::c_void,
    pub hdr_sz: u16,
    pub mss: u16,
}
impl Default for ibv_send_wr__anon_1_tso {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub union ibv_send_wr_qp_type {
    pub xrc: ibv_send_wr_qp_type_xrc,
}
impl Default for ibv_send_wr_qp_type {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_send_wr_qp_type_xrc {
    pub remote_srqn: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub union ibv_send_wr_wr {
    pub rdma: ibv_send_wr_wr_rdma,
    pub atomic: ibv_send_wr_wr_atomic,
    pub ud: ibv_send_wr_wr_ud,
}
impl Default for ibv_send_wr_wr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ibv_send_wr_wr_atomic {
    pub remote_addr: u64,
    pub compare_add: u64,
    pub swap: u64,
    pub rkey: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ibv_send_wr_wr_rdma {
    pub remote_addr: u64,
    pub rkey: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_send_wr_wr_ud {
    pub ah: *mut ibv_ah,
    pub remote_qpn: u32,
    pub remote_qkey: u32,
}
impl Default for ibv_send_wr_wr_ud {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ibv_sge {
    pub addr: u64,
    pub length: u32,
    pub lkey: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_srq {
    pub context: *mut ibv_context,
    pub srq_context: *mut core::ffi::c_void,
    pub pd: *mut ibv_pd,
    pub handle: u32,
    pub mutex: bnd_posix::posix::pthread::pthread_mutex_t,
    pub cond: bnd_posix::posix::pthread::pthread_cond_t,
    pub events_completed: u32,
}
impl Default for ibv_srq {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_srq_attr {
    pub max_wr: u32,
    pub max_sge: u32,
    pub srq_limit: u32,
}
pub type ibv_srq_attr_mask = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_srq_init_attr {
    pub srq_context: *mut core::ffi::c_void,
    pub attr: ibv_srq_attr,
}
impl Default for ibv_srq_init_attr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_srq_init_attr_ex {
    pub srq_context: *mut core::ffi::c_void,
    pub attr: ibv_srq_attr,
    pub comp_mask: u32,
    pub srq_type: ibv_srq_type,
    pub pd: *mut ibv_pd,
    pub xrcd: *mut ibv_xrcd,
    pub cq: *mut ibv_cq,
    pub tm_cap: ibv_tm_cap,
}
impl Default for ibv_srq_init_attr_ex {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_srq_init_attr_mask = u32;
pub type ibv_srq_type = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_td {
    pub context: *mut ibv_context,
}
impl Default for ibv_td {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_td_init_attr {
    pub comp_mask: u32,
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_tm_cap {
    pub max_num_tags: u32,
    pub max_ops: u32,
}
pub type ibv_tm_cap_flags = u32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_tm_caps {
    pub max_rndv_hdr_size: u32,
    pub max_num_tags: u32,
    pub flags: u32,
    pub max_ops: u32,
    pub max_sge: u32,
}
pub type ibv_transport_type = i32;
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_tso_caps {
    pub max_tso: u32,
    pub supported_qpts: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ibv_values_ex {
    pub comp_mask: u32,
    pub raw_clock: bnd_posix::posix::stat::timespec,
}
pub type ibv_values_mask = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_wc {
    pub wr_id: u64,
    pub status: ibv_wc_status,
    pub opcode: ibv_wc_opcode,
    pub vendor_err: u32,
    pub byte_len: u32,
    pub ibv_wc__anon_0: ibv_wc__anon_0,
    pub qp_num: u32,
    pub src_qp: u32,
    pub wc_flags: u32,
    pub pkey_index: u16,
    pub slid: u16,
    pub sl: u8,
    pub dlid_path_bits: u8,
}
impl Default for ibv_wc {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub union ibv_wc__anon_0 {
    pub imm_data: bnd_linux::linux::types::__be32,
    pub invalidated_rkey: u32,
}
impl Default for ibv_wc__anon_0 {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_wc_flags = u32;
pub type ibv_wc_opcode = u32;
pub type ibv_wc_status = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy, Default)]
pub struct ibv_wc_tm_info {
    pub tag: u64,
    pub r#priv: u32,
}
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_wq {
    pub context: *mut ibv_context,
    pub wq_context: *mut core::ffi::c_void,
    pub pd: *mut ibv_pd,
    pub cq: *mut ibv_cq,
    pub wq_num: u32,
    pub handle: u32,
    pub state: ibv_wq_state,
    pub wq_type: ibv_wq_type,
    pub post_recv: *mut isize,
    pub mutex: bnd_posix::posix::pthread::pthread_mutex_t,
    pub cond: bnd_posix::posix::pthread::pthread_cond_t,
    pub events_completed: u32,
    pub comp_mask: u32,
}
impl Default for ibv_wq {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_wq_attr {
    pub attr_mask: u32,
    pub wq_state: ibv_wq_state,
    pub curr_wq_state: ibv_wq_state,
    pub flags: u32,
    pub flags_mask: u32,
}
pub type ibv_wq_attr_mask = u32;
pub type ibv_wq_flags = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_wq_init_attr {
    pub wq_context: *mut core::ffi::c_void,
    pub wq_type: ibv_wq_type,
    pub max_wr: u32,
    pub max_sge: u32,
    pub pd: *mut ibv_pd,
    pub cq: *mut ibv_cq,
    pub comp_mask: u32,
    pub create_flags: u32,
}
impl Default for ibv_wq_init_attr {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
pub type ibv_wq_init_attr_mask = u32;
pub type ibv_wq_state = u32;
pub type ibv_wq_type = u32;
pub type ibv_wr_opcode = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct ibv_xrcd {
    pub context: *mut ibv_context,
}
impl Default for ibv_xrcd {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
#[repr(C, packed(4))]
#[derive(Clone, Copy, Default)]
pub struct ibv_xrcd_init_attr {
    pub comp_mask: u32,
    pub fd: i32,
    pub oflags: i32,
}
pub type ibv_xrcd_init_attr_mask = u32;
pub type rdma_driver_id = u32;
#[repr(C, packed(8))]
#[derive(Clone, Copy)]
pub struct verbs_context {
    pub query_port: *mut isize,
    pub advise_mr: *mut isize,
    pub alloc_null_mr: *mut isize,
    pub read_counters: *mut isize,
    pub attach_counters_point_flow: *mut isize,
    pub create_counters: *mut isize,
    pub destroy_counters: *mut isize,
    pub reg_dm_mr: *mut isize,
    pub alloc_dm: *mut isize,
    pub free_dm: *mut isize,
    pub modify_flow_action_esp: *mut isize,
    pub destroy_flow_action: *mut isize,
    pub create_flow_action_esp: *mut isize,
    pub modify_qp_rate_limit: *mut isize,
    pub alloc_parent_domain: *mut isize,
    pub dealloc_td: *mut isize,
    pub alloc_td: *mut isize,
    pub modify_cq: *mut isize,
    pub post_srq_ops: *mut isize,
    pub destroy_rwq_ind_table: *mut isize,
    pub create_rwq_ind_table: *mut isize,
    pub destroy_wq: *mut isize,
    pub modify_wq: *mut isize,
    pub create_wq: *mut isize,
    pub query_rt_values: *mut isize,
    pub create_cq_ex: *mut isize,
    pub r#priv: *mut core::ffi::c_void,
    pub query_device_ex: *mut isize,
    pub ibv_destroy_flow: *mut isize,
    pub ABI_placeholder2: *mut isize,
    pub ibv_create_flow: *mut isize,
    pub ABI_placeholder1: *mut isize,
    pub open_qp: *mut isize,
    pub create_qp_ex: *mut isize,
    pub get_srq_num: *mut isize,
    pub create_srq_ex: *mut isize,
    pub open_xrcd: *mut isize,
    pub close_xrcd: *mut isize,
    pub _ABI_placeholder3: u64,
    pub sz: u64,
    pub context: ibv_context,
}
impl Default for verbs_context {
    fn default() -> Self {
        unsafe { core::mem::zeroed() }
    }
}
